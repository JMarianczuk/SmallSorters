//------------------------------------------------------------------------------
// <auto-generated>
//     This code was auto-generated by CodeGeneration/Generate.cc
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#ifndef SAMPLESORT_GENERATED_H
#define SAMPLESORT_GENERATED_H

#include <cstring>
#include <inttypes.h>

#include "InsertionSort.h"
#include "../DebugHelper.h"
#include "../custommath/CustomMath.h"
namespace samplesort
{
template <typename Key>
inline
void PerformSplitterComparison(Key &splitterx, Key &splitter2, int &predResult)
{
	
	#if __x86_64__
		__asm__(
			"test %[predResult],%[predResult]\n\t"
			"cmovne %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitterx)
			: "0"(splitterx), [splitter2] "r"(splitter2), [predResult] "r"(predResult)
			: "cc"
		);
	#elif defined(__i386__)
		__asm__(
			"test %[predResult],%[predResult]\n\t"
			"cmovne %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitterx)
			: "0"(splitterx), [splitter2] "r"(splitter2), [predResult] "r"(predResult)
			: "cc"
		);
	#elif __aarch64__
		__asm__(
			"tst %[predResult],%[predResult]\n\t"
			"csel %[splitterx], %[splitter2], %[splitterx], NE\n\t"
			: [splitterx] "=&r"(splitterx)
			: "0"(splitterx), [splitter2] "r"(splitter2), [predResult] "r"(predResult)
			: "cc"
		);
	#elif __arm__
		__asm__(
			"tst %[predResult],%[predResult]\n\t"
			"movne %[splitterx], %[splitter2]\n\t"
			: [splitterx] "=&r"(splitterx)
			: "0"(splitterx), [splitter2] "r"(splitter2), [predResult] "r"(predResult)
			: "cc"
		);
	#else
		if (predResult > 0)
		{
			splitterx = splitter2;
		}
	#endif
	
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
static inline
void Find3Splitters1OversamplingFactor(
	ValueType* items,
	size_t elementCount,
	Key* splitterDestination)
{
	ValueType sample[3];
	int blockSize = elementCount / 3;
	for (int i = 0; i < 3; i += 1)
	{
		sample[i] = items[i * blockSize];
	}
	BaseCaseSorter::sort(sample, 3);
	
	for (int i = 0; i < 3; i += 1)
	{
		splitterDestination[i] = KeyGetter::get(sample[i * 1 + 0]);
	}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
inline
void SampleSortInternal3Splitters1OversamplingFactor1BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		BaseCaseSorter::sort(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	Key splitters[3];
	Find3Splitters1OversamplingFactor<BaseCaseSorter, KeyGetter>(A, elementCount, splitters);
	Key splitter0 = splitters[0];
	Key splitter1 = splitters[1];
	Key splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	Key splitter00x;
	
	int max = elementCount - 1;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters1OversamplingFactor1BlockSize<BaseCaseSorter, KeyGetter>(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, predicateLess, depthLimit - 1);
	}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
void SampleSort3Splitters1OversamplingFactor1BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&))
{
	SampleSortInternal3Splitters1OversamplingFactor1BlockSize<BaseCaseSorter, KeyGetter>(A, elementCount, baseCaseLimit, predicateLess, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
inline
void SampleSortInternal3Splitters1OversamplingFactor2BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		BaseCaseSorter::sort(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	Key splitters[3];
	Find3Splitters1OversamplingFactor<BaseCaseSorter, KeyGetter>(A, elementCount, splitters);
	Key splitter0 = splitters[0];
	Key splitter1 = splitters[1];
	Key splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	Key splitter00x;
	int state1;
	int predicateResult1;
	Key splitter01x;
	
	int max = elementCount - 2;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 2)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		PerformSplitterComparison(splitter01x, splitter2, predicateResult1);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters1OversamplingFactor2BlockSize<BaseCaseSorter, KeyGetter>(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, predicateLess, depthLimit - 1);
	}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
void SampleSort3Splitters1OversamplingFactor2BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&))
{
	SampleSortInternal3Splitters1OversamplingFactor2BlockSize<BaseCaseSorter, KeyGetter>(A, elementCount, baseCaseLimit, predicateLess, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
inline
void SampleSortInternal3Splitters1OversamplingFactor3BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		BaseCaseSorter::sort(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	Key splitters[3];
	Find3Splitters1OversamplingFactor<BaseCaseSorter, KeyGetter>(A, elementCount, splitters);
	Key splitter0 = splitters[0];
	Key splitter1 = splitters[1];
	Key splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	Key splitter00x;
	int state1;
	int predicateResult1;
	Key splitter01x;
	int state2;
	int predicateResult2;
	Key splitter02x;
	
	int max = elementCount - 3;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 3)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		state2 = predicateResult2;
		splitter02x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		PerformSplitterComparison(splitter01x, splitter2, predicateResult1);
		PerformSplitterComparison(splitter02x, splitter2, predicateResult2);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		state2 = (state2 << 1) + predicateResult2;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters1OversamplingFactor3BlockSize<BaseCaseSorter, KeyGetter>(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, predicateLess, depthLimit - 1);
	}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
void SampleSort3Splitters1OversamplingFactor3BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&))
{
	SampleSortInternal3Splitters1OversamplingFactor3BlockSize<BaseCaseSorter, KeyGetter>(A, elementCount, baseCaseLimit, predicateLess, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
inline
void SampleSortInternal3Splitters1OversamplingFactor4BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		BaseCaseSorter::sort(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	Key splitters[3];
	Find3Splitters1OversamplingFactor<BaseCaseSorter, KeyGetter>(A, elementCount, splitters);
	Key splitter0 = splitters[0];
	Key splitter1 = splitters[1];
	Key splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	Key splitter00x;
	int state1;
	int predicateResult1;
	Key splitter01x;
	int state2;
	int predicateResult2;
	Key splitter02x;
	int state3;
	int predicateResult3;
	Key splitter03x;
	
	int max = elementCount - 4;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 4)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		state2 = predicateResult2;
		splitter02x = splitter0;
		predicateResult3 = (int) predicateLess(splitter1, A[current + 3]);
		state3 = predicateResult3;
		splitter03x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		PerformSplitterComparison(splitter01x, splitter2, predicateResult1);
		PerformSplitterComparison(splitter02x, splitter2, predicateResult2);
		PerformSplitterComparison(splitter03x, splitter2, predicateResult3);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		predicateResult3 = (int) predicateLess(splitter03x, A[current + 3]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		state2 = (state2 << 1) + predicateResult2;
		state3 = (state3 << 1) + predicateResult3;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
		*buckets[state3] = A[current + 3];
		buckets[state3]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters1OversamplingFactor4BlockSize<BaseCaseSorter, KeyGetter>(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, predicateLess, depthLimit - 1);
	}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
void SampleSort3Splitters1OversamplingFactor4BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&))
{
	SampleSortInternal3Splitters1OversamplingFactor4BlockSize<BaseCaseSorter, KeyGetter>(A, elementCount, baseCaseLimit, predicateLess, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
inline
void SampleSortInternal3Splitters1OversamplingFactor5BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		BaseCaseSorter::sort(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	Key splitters[3];
	Find3Splitters1OversamplingFactor<BaseCaseSorter, KeyGetter>(A, elementCount, splitters);
	Key splitter0 = splitters[0];
	Key splitter1 = splitters[1];
	Key splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	Key splitter00x;
	int state1;
	int predicateResult1;
	Key splitter01x;
	int state2;
	int predicateResult2;
	Key splitter02x;
	int state3;
	int predicateResult3;
	Key splitter03x;
	int state4;
	int predicateResult4;
	Key splitter04x;
	
	int max = elementCount - 5;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 5)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		state2 = predicateResult2;
		splitter02x = splitter0;
		predicateResult3 = (int) predicateLess(splitter1, A[current + 3]);
		state3 = predicateResult3;
		splitter03x = splitter0;
		predicateResult4 = (int) predicateLess(splitter1, A[current + 4]);
		state4 = predicateResult4;
		splitter04x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		PerformSplitterComparison(splitter01x, splitter2, predicateResult1);
		PerformSplitterComparison(splitter02x, splitter2, predicateResult2);
		PerformSplitterComparison(splitter03x, splitter2, predicateResult3);
		PerformSplitterComparison(splitter04x, splitter2, predicateResult4);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		predicateResult3 = (int) predicateLess(splitter03x, A[current + 3]);
		predicateResult4 = (int) predicateLess(splitter04x, A[current + 4]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		state2 = (state2 << 1) + predicateResult2;
		state3 = (state3 << 1) + predicateResult3;
		state4 = (state4 << 1) + predicateResult4;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
		*buckets[state3] = A[current + 3];
		buckets[state3]++;
		*buckets[state4] = A[current + 4];
		buckets[state4]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters1OversamplingFactor5BlockSize<BaseCaseSorter, KeyGetter>(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, predicateLess, depthLimit - 1);
	}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
void SampleSort3Splitters1OversamplingFactor5BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&))
{
	SampleSortInternal3Splitters1OversamplingFactor5BlockSize<BaseCaseSorter, KeyGetter>(A, elementCount, baseCaseLimit, predicateLess, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
static inline
void Find3Splitters2OversamplingFactor(
	ValueType* items,
	size_t elementCount,
	Key* splitterDestination)
{
	ValueType sample[6];
	int blockSize = elementCount / 6;
	for (int i = 0; i < 6; i += 1)
	{
		sample[i] = items[i * blockSize];
	}
	BaseCaseSorter::sort(sample, 6);
	
	for (int i = 0; i < 3; i += 1)
	{
		splitterDestination[i] = KeyGetter::get(sample[i * 2 + 1]);
	}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
inline
void SampleSortInternal3Splitters2OversamplingFactor1BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		BaseCaseSorter::sort(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	Key splitters[3];
	Find3Splitters2OversamplingFactor<BaseCaseSorter, KeyGetter>(A, elementCount, splitters);
	Key splitter0 = splitters[0];
	Key splitter1 = splitters[1];
	Key splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	Key splitter00x;
	
	int max = elementCount - 1;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters2OversamplingFactor1BlockSize<BaseCaseSorter, KeyGetter>(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, predicateLess, depthLimit - 1);
	}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
void SampleSort3Splitters2OversamplingFactor1BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&))
{
	SampleSortInternal3Splitters2OversamplingFactor1BlockSize<BaseCaseSorter, KeyGetter>(A, elementCount, baseCaseLimit, predicateLess, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
inline
void SampleSortInternal3Splitters2OversamplingFactor2BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		BaseCaseSorter::sort(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	Key splitters[3];
	Find3Splitters2OversamplingFactor<BaseCaseSorter, KeyGetter>(A, elementCount, splitters);
	Key splitter0 = splitters[0];
	Key splitter1 = splitters[1];
	Key splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	Key splitter00x;
	int state1;
	int predicateResult1;
	Key splitter01x;
	
	int max = elementCount - 2;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 2)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		PerformSplitterComparison(splitter01x, splitter2, predicateResult1);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters2OversamplingFactor2BlockSize<BaseCaseSorter, KeyGetter>(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, predicateLess, depthLimit - 1);
	}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
void SampleSort3Splitters2OversamplingFactor2BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&))
{
	SampleSortInternal3Splitters2OversamplingFactor2BlockSize<BaseCaseSorter, KeyGetter>(A, elementCount, baseCaseLimit, predicateLess, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
inline
void SampleSortInternal3Splitters2OversamplingFactor3BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		BaseCaseSorter::sort(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	Key splitters[3];
	Find3Splitters2OversamplingFactor<BaseCaseSorter, KeyGetter>(A, elementCount, splitters);
	Key splitter0 = splitters[0];
	Key splitter1 = splitters[1];
	Key splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	Key splitter00x;
	int state1;
	int predicateResult1;
	Key splitter01x;
	int state2;
	int predicateResult2;
	Key splitter02x;
	
	int max = elementCount - 3;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 3)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		state2 = predicateResult2;
		splitter02x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		PerformSplitterComparison(splitter01x, splitter2, predicateResult1);
		PerformSplitterComparison(splitter02x, splitter2, predicateResult2);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		state2 = (state2 << 1) + predicateResult2;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters2OversamplingFactor3BlockSize<BaseCaseSorter, KeyGetter>(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, predicateLess, depthLimit - 1);
	}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
void SampleSort3Splitters2OversamplingFactor3BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&))
{
	SampleSortInternal3Splitters2OversamplingFactor3BlockSize<BaseCaseSorter, KeyGetter>(A, elementCount, baseCaseLimit, predicateLess, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
inline
void SampleSortInternal3Splitters2OversamplingFactor4BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		BaseCaseSorter::sort(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	Key splitters[3];
	Find3Splitters2OversamplingFactor<BaseCaseSorter, KeyGetter>(A, elementCount, splitters);
	Key splitter0 = splitters[0];
	Key splitter1 = splitters[1];
	Key splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	Key splitter00x;
	int state1;
	int predicateResult1;
	Key splitter01x;
	int state2;
	int predicateResult2;
	Key splitter02x;
	int state3;
	int predicateResult3;
	Key splitter03x;
	
	int max = elementCount - 4;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 4)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		state2 = predicateResult2;
		splitter02x = splitter0;
		predicateResult3 = (int) predicateLess(splitter1, A[current + 3]);
		state3 = predicateResult3;
		splitter03x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		PerformSplitterComparison(splitter01x, splitter2, predicateResult1);
		PerformSplitterComparison(splitter02x, splitter2, predicateResult2);
		PerformSplitterComparison(splitter03x, splitter2, predicateResult3);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		predicateResult3 = (int) predicateLess(splitter03x, A[current + 3]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		state2 = (state2 << 1) + predicateResult2;
		state3 = (state3 << 1) + predicateResult3;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
		*buckets[state3] = A[current + 3];
		buckets[state3]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters2OversamplingFactor4BlockSize<BaseCaseSorter, KeyGetter>(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, predicateLess, depthLimit - 1);
	}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
void SampleSort3Splitters2OversamplingFactor4BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&))
{
	SampleSortInternal3Splitters2OversamplingFactor4BlockSize<BaseCaseSorter, KeyGetter>(A, elementCount, baseCaseLimit, predicateLess, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
inline
void SampleSortInternal3Splitters2OversamplingFactor5BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		BaseCaseSorter::sort(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	Key splitters[3];
	Find3Splitters2OversamplingFactor<BaseCaseSorter, KeyGetter>(A, elementCount, splitters);
	Key splitter0 = splitters[0];
	Key splitter1 = splitters[1];
	Key splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	Key splitter00x;
	int state1;
	int predicateResult1;
	Key splitter01x;
	int state2;
	int predicateResult2;
	Key splitter02x;
	int state3;
	int predicateResult3;
	Key splitter03x;
	int state4;
	int predicateResult4;
	Key splitter04x;
	
	int max = elementCount - 5;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 5)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		state2 = predicateResult2;
		splitter02x = splitter0;
		predicateResult3 = (int) predicateLess(splitter1, A[current + 3]);
		state3 = predicateResult3;
		splitter03x = splitter0;
		predicateResult4 = (int) predicateLess(splitter1, A[current + 4]);
		state4 = predicateResult4;
		splitter04x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		PerformSplitterComparison(splitter01x, splitter2, predicateResult1);
		PerformSplitterComparison(splitter02x, splitter2, predicateResult2);
		PerformSplitterComparison(splitter03x, splitter2, predicateResult3);
		PerformSplitterComparison(splitter04x, splitter2, predicateResult4);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		predicateResult3 = (int) predicateLess(splitter03x, A[current + 3]);
		predicateResult4 = (int) predicateLess(splitter04x, A[current + 4]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		state2 = (state2 << 1) + predicateResult2;
		state3 = (state3 << 1) + predicateResult3;
		state4 = (state4 << 1) + predicateResult4;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
		*buckets[state3] = A[current + 3];
		buckets[state3]++;
		*buckets[state4] = A[current + 4];
		buckets[state4]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters2OversamplingFactor5BlockSize<BaseCaseSorter, KeyGetter>(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, predicateLess, depthLimit - 1);
	}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
void SampleSort3Splitters2OversamplingFactor5BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&))
{
	SampleSortInternal3Splitters2OversamplingFactor5BlockSize<BaseCaseSorter, KeyGetter>(A, elementCount, baseCaseLimit, predicateLess, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
static inline
void Find3Splitters3OversamplingFactor(
	ValueType* items,
	size_t elementCount,
	Key* splitterDestination)
{
	ValueType sample[9];
	int blockSize = elementCount / 9;
	for (int i = 0; i < 9; i += 1)
	{
		sample[i] = items[i * blockSize];
	}
	BaseCaseSorter::sort(sample, 9);
	
	for (int i = 0; i < 3; i += 1)
	{
		splitterDestination[i] = KeyGetter::get(sample[i * 3 + 1]);
	}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
inline
void SampleSortInternal3Splitters3OversamplingFactor1BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		BaseCaseSorter::sort(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	Key splitters[3];
	Find3Splitters3OversamplingFactor<BaseCaseSorter, KeyGetter>(A, elementCount, splitters);
	Key splitter0 = splitters[0];
	Key splitter1 = splitters[1];
	Key splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	Key splitter00x;
	
	int max = elementCount - 1;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters3OversamplingFactor1BlockSize<BaseCaseSorter, KeyGetter>(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, predicateLess, depthLimit - 1);
	}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
void SampleSort3Splitters3OversamplingFactor1BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&))
{
	SampleSortInternal3Splitters3OversamplingFactor1BlockSize<BaseCaseSorter, KeyGetter>(A, elementCount, baseCaseLimit, predicateLess, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
inline
void SampleSortInternal3Splitters3OversamplingFactor2BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		BaseCaseSorter::sort(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	Key splitters[3];
	Find3Splitters3OversamplingFactor<BaseCaseSorter, KeyGetter>(A, elementCount, splitters);
	Key splitter0 = splitters[0];
	Key splitter1 = splitters[1];
	Key splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	Key splitter00x;
	int state1;
	int predicateResult1;
	Key splitter01x;
	
	int max = elementCount - 2;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 2)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		PerformSplitterComparison(splitter01x, splitter2, predicateResult1);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters3OversamplingFactor2BlockSize<BaseCaseSorter, KeyGetter>(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, predicateLess, depthLimit - 1);
	}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
void SampleSort3Splitters3OversamplingFactor2BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&))
{
	SampleSortInternal3Splitters3OversamplingFactor2BlockSize<BaseCaseSorter, KeyGetter>(A, elementCount, baseCaseLimit, predicateLess, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
inline
void SampleSortInternal3Splitters3OversamplingFactor3BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		BaseCaseSorter::sort(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	Key splitters[3];
	Find3Splitters3OversamplingFactor<BaseCaseSorter, KeyGetter>(A, elementCount, splitters);
	Key splitter0 = splitters[0];
	Key splitter1 = splitters[1];
	Key splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	Key splitter00x;
	int state1;
	int predicateResult1;
	Key splitter01x;
	int state2;
	int predicateResult2;
	Key splitter02x;
	
	int max = elementCount - 3;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 3)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		state2 = predicateResult2;
		splitter02x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		PerformSplitterComparison(splitter01x, splitter2, predicateResult1);
		PerformSplitterComparison(splitter02x, splitter2, predicateResult2);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		state2 = (state2 << 1) + predicateResult2;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters3OversamplingFactor3BlockSize<BaseCaseSorter, KeyGetter>(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, predicateLess, depthLimit - 1);
	}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
void SampleSort3Splitters3OversamplingFactor3BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&))
{
	SampleSortInternal3Splitters3OversamplingFactor3BlockSize<BaseCaseSorter, KeyGetter>(A, elementCount, baseCaseLimit, predicateLess, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
inline
void SampleSortInternal3Splitters3OversamplingFactor4BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		BaseCaseSorter::sort(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	Key splitters[3];
	Find3Splitters3OversamplingFactor<BaseCaseSorter, KeyGetter>(A, elementCount, splitters);
	Key splitter0 = splitters[0];
	Key splitter1 = splitters[1];
	Key splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	Key splitter00x;
	int state1;
	int predicateResult1;
	Key splitter01x;
	int state2;
	int predicateResult2;
	Key splitter02x;
	int state3;
	int predicateResult3;
	Key splitter03x;
	
	int max = elementCount - 4;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 4)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		state2 = predicateResult2;
		splitter02x = splitter0;
		predicateResult3 = (int) predicateLess(splitter1, A[current + 3]);
		state3 = predicateResult3;
		splitter03x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		PerformSplitterComparison(splitter01x, splitter2, predicateResult1);
		PerformSplitterComparison(splitter02x, splitter2, predicateResult2);
		PerformSplitterComparison(splitter03x, splitter2, predicateResult3);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		predicateResult3 = (int) predicateLess(splitter03x, A[current + 3]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		state2 = (state2 << 1) + predicateResult2;
		state3 = (state3 << 1) + predicateResult3;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
		*buckets[state3] = A[current + 3];
		buckets[state3]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters3OversamplingFactor4BlockSize<BaseCaseSorter, KeyGetter>(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, predicateLess, depthLimit - 1);
	}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
void SampleSort3Splitters3OversamplingFactor4BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&))
{
	SampleSortInternal3Splitters3OversamplingFactor4BlockSize<BaseCaseSorter, KeyGetter>(A, elementCount, baseCaseLimit, predicateLess, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
inline
void SampleSortInternal3Splitters3OversamplingFactor5BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		BaseCaseSorter::sort(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	Key splitters[3];
	Find3Splitters3OversamplingFactor<BaseCaseSorter, KeyGetter>(A, elementCount, splitters);
	Key splitter0 = splitters[0];
	Key splitter1 = splitters[1];
	Key splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	Key splitter00x;
	int state1;
	int predicateResult1;
	Key splitter01x;
	int state2;
	int predicateResult2;
	Key splitter02x;
	int state3;
	int predicateResult3;
	Key splitter03x;
	int state4;
	int predicateResult4;
	Key splitter04x;
	
	int max = elementCount - 5;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 5)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		state2 = predicateResult2;
		splitter02x = splitter0;
		predicateResult3 = (int) predicateLess(splitter1, A[current + 3]);
		state3 = predicateResult3;
		splitter03x = splitter0;
		predicateResult4 = (int) predicateLess(splitter1, A[current + 4]);
		state4 = predicateResult4;
		splitter04x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		PerformSplitterComparison(splitter01x, splitter2, predicateResult1);
		PerformSplitterComparison(splitter02x, splitter2, predicateResult2);
		PerformSplitterComparison(splitter03x, splitter2, predicateResult3);
		PerformSplitterComparison(splitter04x, splitter2, predicateResult4);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		predicateResult3 = (int) predicateLess(splitter03x, A[current + 3]);
		predicateResult4 = (int) predicateLess(splitter04x, A[current + 4]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		state2 = (state2 << 1) + predicateResult2;
		state3 = (state3 << 1) + predicateResult3;
		state4 = (state4 << 1) + predicateResult4;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
		*buckets[state3] = A[current + 3];
		buckets[state3]++;
		*buckets[state4] = A[current + 4];
		buckets[state4]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters3OversamplingFactor5BlockSize<BaseCaseSorter, KeyGetter>(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, predicateLess, depthLimit - 1);
	}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
void SampleSort3Splitters3OversamplingFactor5BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&))
{
	SampleSortInternal3Splitters3OversamplingFactor5BlockSize<BaseCaseSorter, KeyGetter>(A, elementCount, baseCaseLimit, predicateLess, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
static inline
void Find3Splitters4OversamplingFactor(
	ValueType* items,
	size_t elementCount,
	Key* splitterDestination)
{
	ValueType sample[12];
	int blockSize = elementCount / 12;
	for (int i = 0; i < 12; i += 1)
	{
		sample[i] = items[i * blockSize];
	}
	BaseCaseSorter::sort(sample, 12);
	
	for (int i = 0; i < 3; i += 1)
	{
		splitterDestination[i] = KeyGetter::get(sample[i * 4 + 2]);
	}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
inline
void SampleSortInternal3Splitters4OversamplingFactor1BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		BaseCaseSorter::sort(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	Key splitters[3];
	Find3Splitters4OversamplingFactor<BaseCaseSorter, KeyGetter>(A, elementCount, splitters);
	Key splitter0 = splitters[0];
	Key splitter1 = splitters[1];
	Key splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	Key splitter00x;
	
	int max = elementCount - 1;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters4OversamplingFactor1BlockSize<BaseCaseSorter, KeyGetter>(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, predicateLess, depthLimit - 1);
	}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
void SampleSort3Splitters4OversamplingFactor1BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&))
{
	SampleSortInternal3Splitters4OversamplingFactor1BlockSize<BaseCaseSorter, KeyGetter>(A, elementCount, baseCaseLimit, predicateLess, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
inline
void SampleSortInternal3Splitters4OversamplingFactor2BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		BaseCaseSorter::sort(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	Key splitters[3];
	Find3Splitters4OversamplingFactor<BaseCaseSorter, KeyGetter>(A, elementCount, splitters);
	Key splitter0 = splitters[0];
	Key splitter1 = splitters[1];
	Key splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	Key splitter00x;
	int state1;
	int predicateResult1;
	Key splitter01x;
	
	int max = elementCount - 2;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 2)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		PerformSplitterComparison(splitter01x, splitter2, predicateResult1);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters4OversamplingFactor2BlockSize<BaseCaseSorter, KeyGetter>(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, predicateLess, depthLimit - 1);
	}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
void SampleSort3Splitters4OversamplingFactor2BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&))
{
	SampleSortInternal3Splitters4OversamplingFactor2BlockSize<BaseCaseSorter, KeyGetter>(A, elementCount, baseCaseLimit, predicateLess, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
inline
void SampleSortInternal3Splitters4OversamplingFactor3BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		BaseCaseSorter::sort(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	Key splitters[3];
	Find3Splitters4OversamplingFactor<BaseCaseSorter, KeyGetter>(A, elementCount, splitters);
	Key splitter0 = splitters[0];
	Key splitter1 = splitters[1];
	Key splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	Key splitter00x;
	int state1;
	int predicateResult1;
	Key splitter01x;
	int state2;
	int predicateResult2;
	Key splitter02x;
	
	int max = elementCount - 3;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 3)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		state2 = predicateResult2;
		splitter02x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		PerformSplitterComparison(splitter01x, splitter2, predicateResult1);
		PerformSplitterComparison(splitter02x, splitter2, predicateResult2);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		state2 = (state2 << 1) + predicateResult2;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters4OversamplingFactor3BlockSize<BaseCaseSorter, KeyGetter>(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, predicateLess, depthLimit - 1);
	}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
void SampleSort3Splitters4OversamplingFactor3BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&))
{
	SampleSortInternal3Splitters4OversamplingFactor3BlockSize<BaseCaseSorter, KeyGetter>(A, elementCount, baseCaseLimit, predicateLess, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
inline
void SampleSortInternal3Splitters4OversamplingFactor4BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		BaseCaseSorter::sort(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	Key splitters[3];
	Find3Splitters4OversamplingFactor<BaseCaseSorter, KeyGetter>(A, elementCount, splitters);
	Key splitter0 = splitters[0];
	Key splitter1 = splitters[1];
	Key splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	Key splitter00x;
	int state1;
	int predicateResult1;
	Key splitter01x;
	int state2;
	int predicateResult2;
	Key splitter02x;
	int state3;
	int predicateResult3;
	Key splitter03x;
	
	int max = elementCount - 4;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 4)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		state2 = predicateResult2;
		splitter02x = splitter0;
		predicateResult3 = (int) predicateLess(splitter1, A[current + 3]);
		state3 = predicateResult3;
		splitter03x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		PerformSplitterComparison(splitter01x, splitter2, predicateResult1);
		PerformSplitterComparison(splitter02x, splitter2, predicateResult2);
		PerformSplitterComparison(splitter03x, splitter2, predicateResult3);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		predicateResult3 = (int) predicateLess(splitter03x, A[current + 3]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		state2 = (state2 << 1) + predicateResult2;
		state3 = (state3 << 1) + predicateResult3;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
		*buckets[state3] = A[current + 3];
		buckets[state3]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters4OversamplingFactor4BlockSize<BaseCaseSorter, KeyGetter>(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, predicateLess, depthLimit - 1);
	}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
void SampleSort3Splitters4OversamplingFactor4BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&))
{
	SampleSortInternal3Splitters4OversamplingFactor4BlockSize<BaseCaseSorter, KeyGetter>(A, elementCount, baseCaseLimit, predicateLess, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
inline
void SampleSortInternal3Splitters4OversamplingFactor5BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		BaseCaseSorter::sort(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	Key splitters[3];
	Find3Splitters4OversamplingFactor<BaseCaseSorter, KeyGetter>(A, elementCount, splitters);
	Key splitter0 = splitters[0];
	Key splitter1 = splitters[1];
	Key splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	Key splitter00x;
	int state1;
	int predicateResult1;
	Key splitter01x;
	int state2;
	int predicateResult2;
	Key splitter02x;
	int state3;
	int predicateResult3;
	Key splitter03x;
	int state4;
	int predicateResult4;
	Key splitter04x;
	
	int max = elementCount - 5;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 5)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		state2 = predicateResult2;
		splitter02x = splitter0;
		predicateResult3 = (int) predicateLess(splitter1, A[current + 3]);
		state3 = predicateResult3;
		splitter03x = splitter0;
		predicateResult4 = (int) predicateLess(splitter1, A[current + 4]);
		state4 = predicateResult4;
		splitter04x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		PerformSplitterComparison(splitter01x, splitter2, predicateResult1);
		PerformSplitterComparison(splitter02x, splitter2, predicateResult2);
		PerformSplitterComparison(splitter03x, splitter2, predicateResult3);
		PerformSplitterComparison(splitter04x, splitter2, predicateResult4);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		predicateResult3 = (int) predicateLess(splitter03x, A[current + 3]);
		predicateResult4 = (int) predicateLess(splitter04x, A[current + 4]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		state2 = (state2 << 1) + predicateResult2;
		state3 = (state3 << 1) + predicateResult3;
		state4 = (state4 << 1) + predicateResult4;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
		*buckets[state3] = A[current + 3];
		buckets[state3]++;
		*buckets[state4] = A[current + 4];
		buckets[state4]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters4OversamplingFactor5BlockSize<BaseCaseSorter, KeyGetter>(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, predicateLess, depthLimit - 1);
	}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
void SampleSort3Splitters4OversamplingFactor5BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&))
{
	SampleSortInternal3Splitters4OversamplingFactor5BlockSize<BaseCaseSorter, KeyGetter>(A, elementCount, baseCaseLimit, predicateLess, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
static inline
void Find3Splitters5OversamplingFactor(
	ValueType* items,
	size_t elementCount,
	Key* splitterDestination)
{
	ValueType sample[15];
	int blockSize = elementCount / 15;
	for (int i = 0; i < 15; i += 1)
	{
		sample[i] = items[i * blockSize];
	}
	BaseCaseSorter::sort(sample, 15);
	
	for (int i = 0; i < 3; i += 1)
	{
		splitterDestination[i] = KeyGetter::get(sample[i * 5 + 2]);
	}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
inline
void SampleSortInternal3Splitters5OversamplingFactor1BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		BaseCaseSorter::sort(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	Key splitters[3];
	Find3Splitters5OversamplingFactor<BaseCaseSorter, KeyGetter>(A, elementCount, splitters);
	Key splitter0 = splitters[0];
	Key splitter1 = splitters[1];
	Key splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	Key splitter00x;
	
	int max = elementCount - 1;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters5OversamplingFactor1BlockSize<BaseCaseSorter, KeyGetter>(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, predicateLess, depthLimit - 1);
	}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
void SampleSort3Splitters5OversamplingFactor1BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&))
{
	SampleSortInternal3Splitters5OversamplingFactor1BlockSize<BaseCaseSorter, KeyGetter>(A, elementCount, baseCaseLimit, predicateLess, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
inline
void SampleSortInternal3Splitters5OversamplingFactor2BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		BaseCaseSorter::sort(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	Key splitters[3];
	Find3Splitters5OversamplingFactor<BaseCaseSorter, KeyGetter>(A, elementCount, splitters);
	Key splitter0 = splitters[0];
	Key splitter1 = splitters[1];
	Key splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	Key splitter00x;
	int state1;
	int predicateResult1;
	Key splitter01x;
	
	int max = elementCount - 2;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 2)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		PerformSplitterComparison(splitter01x, splitter2, predicateResult1);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters5OversamplingFactor2BlockSize<BaseCaseSorter, KeyGetter>(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, predicateLess, depthLimit - 1);
	}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
void SampleSort3Splitters5OversamplingFactor2BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&))
{
	SampleSortInternal3Splitters5OversamplingFactor2BlockSize<BaseCaseSorter, KeyGetter>(A, elementCount, baseCaseLimit, predicateLess, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
inline
void SampleSortInternal3Splitters5OversamplingFactor3BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		BaseCaseSorter::sort(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	Key splitters[3];
	Find3Splitters5OversamplingFactor<BaseCaseSorter, KeyGetter>(A, elementCount, splitters);
	Key splitter0 = splitters[0];
	Key splitter1 = splitters[1];
	Key splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	Key splitter00x;
	int state1;
	int predicateResult1;
	Key splitter01x;
	int state2;
	int predicateResult2;
	Key splitter02x;
	
	int max = elementCount - 3;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 3)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		state2 = predicateResult2;
		splitter02x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		PerformSplitterComparison(splitter01x, splitter2, predicateResult1);
		PerformSplitterComparison(splitter02x, splitter2, predicateResult2);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		state2 = (state2 << 1) + predicateResult2;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters5OversamplingFactor3BlockSize<BaseCaseSorter, KeyGetter>(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, predicateLess, depthLimit - 1);
	}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
void SampleSort3Splitters5OversamplingFactor3BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&))
{
	SampleSortInternal3Splitters5OversamplingFactor3BlockSize<BaseCaseSorter, KeyGetter>(A, elementCount, baseCaseLimit, predicateLess, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
inline
void SampleSortInternal3Splitters5OversamplingFactor4BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		BaseCaseSorter::sort(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	Key splitters[3];
	Find3Splitters5OversamplingFactor<BaseCaseSorter, KeyGetter>(A, elementCount, splitters);
	Key splitter0 = splitters[0];
	Key splitter1 = splitters[1];
	Key splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	Key splitter00x;
	int state1;
	int predicateResult1;
	Key splitter01x;
	int state2;
	int predicateResult2;
	Key splitter02x;
	int state3;
	int predicateResult3;
	Key splitter03x;
	
	int max = elementCount - 4;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 4)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		state2 = predicateResult2;
		splitter02x = splitter0;
		predicateResult3 = (int) predicateLess(splitter1, A[current + 3]);
		state3 = predicateResult3;
		splitter03x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		PerformSplitterComparison(splitter01x, splitter2, predicateResult1);
		PerformSplitterComparison(splitter02x, splitter2, predicateResult2);
		PerformSplitterComparison(splitter03x, splitter2, predicateResult3);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		predicateResult3 = (int) predicateLess(splitter03x, A[current + 3]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		state2 = (state2 << 1) + predicateResult2;
		state3 = (state3 << 1) + predicateResult3;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
		*buckets[state3] = A[current + 3];
		buckets[state3]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters5OversamplingFactor4BlockSize<BaseCaseSorter, KeyGetter>(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, predicateLess, depthLimit - 1);
	}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
void SampleSort3Splitters5OversamplingFactor4BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&))
{
	SampleSortInternal3Splitters5OversamplingFactor4BlockSize<BaseCaseSorter, KeyGetter>(A, elementCount, baseCaseLimit, predicateLess, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
inline
void SampleSortInternal3Splitters5OversamplingFactor5BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		BaseCaseSorter::sort(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	Key splitters[3];
	Find3Splitters5OversamplingFactor<BaseCaseSorter, KeyGetter>(A, elementCount, splitters);
	Key splitter0 = splitters[0];
	Key splitter1 = splitters[1];
	Key splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	Key splitter00x;
	int state1;
	int predicateResult1;
	Key splitter01x;
	int state2;
	int predicateResult2;
	Key splitter02x;
	int state3;
	int predicateResult3;
	Key splitter03x;
	int state4;
	int predicateResult4;
	Key splitter04x;
	
	int max = elementCount - 5;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 5)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		state2 = predicateResult2;
		splitter02x = splitter0;
		predicateResult3 = (int) predicateLess(splitter1, A[current + 3]);
		state3 = predicateResult3;
		splitter03x = splitter0;
		predicateResult4 = (int) predicateLess(splitter1, A[current + 4]);
		state4 = predicateResult4;
		splitter04x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		PerformSplitterComparison(splitter01x, splitter2, predicateResult1);
		PerformSplitterComparison(splitter02x, splitter2, predicateResult2);
		PerformSplitterComparison(splitter03x, splitter2, predicateResult3);
		PerformSplitterComparison(splitter04x, splitter2, predicateResult4);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		predicateResult3 = (int) predicateLess(splitter03x, A[current + 3]);
		predicateResult4 = (int) predicateLess(splitter04x, A[current + 4]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		state2 = (state2 << 1) + predicateResult2;
		state3 = (state3 << 1) + predicateResult3;
		state4 = (state4 << 1) + predicateResult4;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
		*buckets[state3] = A[current + 3];
		buckets[state3]++;
		*buckets[state4] = A[current + 4];
		buckets[state4]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		PerformSplitterComparison(splitter00x, splitter2, predicateResult0);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters5OversamplingFactor5BlockSize<BaseCaseSorter, KeyGetter>(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, predicateLess, depthLimit - 1);
	}
}
template <typename BaseCaseSorter, typename KeyGetter, typename ValueType, typename Key>
void SampleSort3Splitters5OversamplingFactor5BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	bool(*predicateLess)(Key&,ValueType&))
{
	SampleSortInternal3Splitters5OversamplingFactor5BlockSize<BaseCaseSorter, KeyGetter>(A, elementCount, baseCaseLimit, predicateLess, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
} // namespace samplesort

#endif // SAMPLESORT_GENERATED_H
