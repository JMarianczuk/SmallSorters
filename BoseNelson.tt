<#@ template language="C#" hostspecific="True" compilerOptions="/langversion:7"#>
<#@ output extension=".generated.h"#>

<#@ include file="Networks.tt"#>

<#@ assembly name="System.Core"#>

<#@ import namespace="System"#>
<#@ import namespace="System.Collections.Generic"#>

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was auto-generated from a T4 template
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#ifndef BOSENELSON_GENERATED_H
#define BOSENELSON_GENERATED_H

#include "NetworkSort.h"

namespace networks {

<#
    for (int arraySize = 2; arraySize <= 16; arraySize += 1)
    {
        WriteBoseNelson(arraySize);
    }
    
    void WriteBoseNelson(int size)
    {
        WriteLine("template <typename TValueType> static inline");
        WriteLine($"void sort{size}bosenelson(TValueType* A)");
        WriteLine("{");
        PushIndent("\t");
        WriteSwaps(BoseNelsonSplit(0, size));
        PopIndent();
        WriteLine("}");
    }
    IEnumerable<ConditionalSwap> BoseNelsonSplit(int start, int length)
    {
        if (length >= 2)
        {
            int middle = length / 2;
            return Append(
                BoseNelsonSplit(start, middle),
                BoseNelsonSplit(start + middle, length - middle),
                BoseNelsonMerge(start, middle, start + middle, length - middle)
            );
        }
        return new ConditionalSwap[0];
    }
    IEnumerable<ConditionalSwap> BoseNelsonMerge(int leftStart, int leftLength, int rightStart, int rightLength)
    {
        if (leftLength == 1 && rightLength == 1)
        {
            return new[] { new ConditionalSwap(leftStart, rightStart) };
        }
        if (leftLength == 1 && rightLength == 2)
        {
            return new[] { new ConditionalSwap(leftStart, rightStart + 1), new ConditionalSwap(leftStart, rightStart) };
        }
        if (leftLength == 2 && rightLength == 1)
        {
            return new[] { new ConditionalSwap(leftStart, rightStart), new ConditionalSwap(leftStart + 1, rightStart) };
        }

        int leftMiddle = leftLength / 2;
        int rightMiddle = rightLength / 2;

        return Append(
            BoseNelsonMerge(leftStart, leftMiddle, rightStart, rightMiddle),
            BoseNelsonMerge(leftStart + leftMiddle, leftLength - leftMiddle, rightStart + rightMiddle, rightLength - rightMiddle),
            BoseNelsonMerge(leftStart + leftMiddle, leftLength - leftMiddle, rightStart, rightMiddle)
        );
    }

    IEnumerable<T> Append<T>(params IEnumerable<T>[] appendees)
        {
            foreach (var ienum in appendees)
            {
                foreach (var element in ienum)
                {
                    yield return element;
                }
            }
        }
#>


template <typename TValueType> static inline
void sortNbosenelson(TValueType* A, size_t n)
{
    switch(n) {
        case 0: break;
        case 1: break;
        <#
            PushIndent("\t");
            PushIndent("\t");
            for (int arraySize = 2; arraySize <= 16; arraySize += 1)
            {
                WriteLine($"case {arraySize}:");
                PushIndent("\t");
                WriteLine($"sort{arraySize}bosenelson(A);");
                WriteLine("break;");
                PopIndent();
            }
            PopIndent();
            PopIndent();
        #>
    }
}

}

#endif