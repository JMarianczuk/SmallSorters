


//------------------------------------------------------------------------------
// <auto-generated>
//     This code was auto-generated from a T4 template
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#ifndef RANDOMISATION_GENERATED_H
#define RANDOMISATION_GENERATED_H

#include "Randomisation.h"

namespace randomisation
{

template<typename TValueType>
void GenerateRandomArray(TValueType* arr, size_t arraySize) {
    throw std::logic_error("randomisation::GenerateRandomArray => Not implemented for generic type");
}

template<>
void GenerateRandomArray<SortableRef>(SortableRef* arr, size_t arraySize) {
	uint64_t reference = randomisation::GenerateRandomUint64();
	for (int i = 0; i < arraySize; i += 1) {
		arr[i].key = randomisation::GenerateRandomUint64();
		arr[i].reference = reference + i;
	}
}
template<>
void GenerateRandomArray<Sortable_JumpXchg>(Sortable_JumpXchg* arr, size_t arraySize) {
	for (int i = 0; i < arraySize; i += 1) {
		arr[i].key = randomisation::GenerateRandomUint64();
	}
}
template<>
void GenerateRandomArray<SortableRef_JumpXchg>(SortableRef_JumpXchg* arr, size_t arraySize) {
	uint64_t reference = randomisation::GenerateRandomUint64();
	for (int i = 0; i < arraySize; i += 1) {
		arr[i].key = randomisation::GenerateRandomUint64();
		arr[i].reference = reference + i;
	}
}
template<>
void GenerateRandomArray<Sortable_TwoCmovTemp>(Sortable_TwoCmovTemp* arr, size_t arraySize) {
	for (int i = 0; i < arraySize; i += 1) {
		arr[i].key = randomisation::GenerateRandomUint64();
	}
}
template<>
void GenerateRandomArray<SortableRef_FourCmovTemp>(SortableRef_FourCmovTemp* arr, size_t arraySize) {
	uint64_t reference = randomisation::GenerateRandomUint64();
	for (int i = 0; i < arraySize; i += 1) {
		arr[i].key = randomisation::GenerateRandomUint64();
		arr[i].reference = reference + i;
	}
}
template<>
void GenerateRandomArray<SortableRef_FourCmovTemp_Split>(SortableRef_FourCmovTemp_Split* arr, size_t arraySize) {
	uint64_t reference = randomisation::GenerateRandomUint64();
	for (int i = 0; i < arraySize; i += 1) {
		arr[i].key = randomisation::GenerateRandomUint64();
		arr[i].reference = reference + i;
	}
}
template<>
void GenerateRandomArray<Sortable_ThreeCmovRegisterTemp>(Sortable_ThreeCmovRegisterTemp* arr, size_t arraySize) {
	for (int i = 0; i < arraySize; i += 1) {
		arr[i].key = randomisation::GenerateRandomUint64();
	}
}
template<>
void GenerateRandomArray<SortableRef_SixCmovRegisterTemp>(SortableRef_SixCmovRegisterTemp* arr, size_t arraySize) {
	uint64_t reference = randomisation::GenerateRandomUint64();
	for (int i = 0; i < arraySize; i += 1) {
		arr[i].key = randomisation::GenerateRandomUint64();
		arr[i].reference = reference + i;
	}
}
template<>
void GenerateRandomArray<SortableRef_ClangVersion>(SortableRef_ClangVersion* arr, size_t arraySize) {
	uint64_t reference = randomisation::GenerateRandomUint64();
	for (int i = 0; i < arraySize; i += 1) {
		arr[i].key = randomisation::GenerateRandomUint64();
		arr[i].reference = reference + i;
	}
}
template<>
void GenerateRandomArray<SortableRef_StlVersion>(SortableRef_StlVersion* arr, size_t arraySize) {
	uint64_t reference = randomisation::GenerateRandomUint64();
	for (int i = 0; i < arraySize; i += 1) {
		arr[i].key = randomisation::GenerateRandomUint64();
		arr[i].reference = reference + i;
	}
}
template<>
void GenerateRandomArray<SortableRef_PointerOptimized>(SortableRef_PointerOptimized* arr, size_t arraySize) {
	uint64_t reference = randomisation::GenerateRandomUint64();
	for (int i = 0; i < arraySize; i += 1) {
		arr[i].key = randomisation::GenerateRandomUint64();
		arr[i].reference = reference + i;
	}
}

}

#endif