//------------------------------------------------------------------------------
// <auto-generated>
//     This code was auto-generated
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#ifndef SAMPLESORT_GENERATED_H
#define SAMPLESORT_GENERATED_H

#include <cstring>
#include <inttypes.h>

#include "DebugHelper.h"
namespace samplesort
{
template <typename TValueType, typename TKey>
static inline
void Find3Splitters1OversamplingFactor(
	TValueType* items,
	size_t elementCount,
	TKey* splitterDestination,
	void(*sortFunc)(TValueType*,size_t),
	TKey(*getKeyFunc)(TValueType&))
{
	TValueType sample[3];
	int blockSize = elementCount / 3;
	for (int i = 0; i < 3; i += 1)
	{
		sample[i] = items[i * blockSize];
	}
	sortFunc(sample, 3);
	
	for (int i = 0; i < 3; i += 1)
	{
		splitterDestination[i] = getKeyFunc(sample[i * 1 + 0]);
	}
}
template <typename TValueType, typename TKey>
static inline
void SampleSort3Splitters1OversamplingFactor1BlockSize(
	TValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(TValueType*,size_t),
	bool(*predicateLess)(TKey&,TValueType&),
	TKey(*getKeyFunc)(TValueType&))
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	TKey splitters[3];
	Find3Splitters1OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	register TKey splitter0 = splitters[0];
	register TKey splitter1 = splitters[1];
	register TKey splitter2 = splitters[2];
	
	TValueType *rawbuckets = (TValueType*) malloc(sizeof(TValueType) * 4 * elementCount);
	TValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	register int state0;
	register int predicateResult0;
	register TKey splitter00x;
	
	int max = elementCount - 1;
	int current = 0;
	register int zero = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 1)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	TValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(TValueType));
		currentPos += bucketSize[currentBucket];
	}
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSort3Splitters1OversamplingFactor1BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc);
	}
}
template <typename TValueType, typename TKey>
static inline
void SampleSort3Splitters1OversamplingFactor2BlockSize(
	TValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(TValueType*,size_t),
	bool(*predicateLess)(TKey&,TValueType&),
	TKey(*getKeyFunc)(TValueType&))
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	TKey splitters[3];
	Find3Splitters1OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	register TKey splitter0 = splitters[0];
	register TKey splitter1 = splitters[1];
	register TKey splitter2 = splitters[2];
	
	TValueType *rawbuckets = (TValueType*) malloc(sizeof(TValueType) * 4 * elementCount);
	TValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	register int state0;
	register int predicateResult0;
	register TKey splitter00x;
	register int state1;
	register int predicateResult1;
	register TKey splitter01x;
	
	int max = elementCount - 2;
	int current = 0;
	register int zero = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 2)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		state1 = 0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		splitter01x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter01x), [state] "=&r"(state1)
			: "0"(splitter01x), "1"(state1), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state1)
			: "0"(state1), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	TValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(TValueType));
		currentPos += bucketSize[currentBucket];
	}
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSort3Splitters1OversamplingFactor2BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc);
	}
}
template <typename TValueType, typename TKey>
static inline
void SampleSort3Splitters1OversamplingFactor3BlockSize(
	TValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(TValueType*,size_t),
	bool(*predicateLess)(TKey&,TValueType&),
	TKey(*getKeyFunc)(TValueType&))
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	TKey splitters[3];
	Find3Splitters1OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	register TKey splitter0 = splitters[0];
	register TKey splitter1 = splitters[1];
	register TKey splitter2 = splitters[2];
	
	TValueType *rawbuckets = (TValueType*) malloc(sizeof(TValueType) * 4 * elementCount);
	TValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	register int state0;
	register int predicateResult0;
	register TKey splitter00x;
	register int state1;
	register int predicateResult1;
	register TKey splitter01x;
	register int state2;
	register int predicateResult2;
	register TKey splitter02x;
	
	int max = elementCount - 3;
	int current = 0;
	register int zero = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 3)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		state1 = 0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		splitter01x = splitter0;
		state2 = 0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		splitter02x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter01x), [state] "=&r"(state1)
			: "0"(splitter01x), "1"(state1), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter02x), [state] "=&r"(state2)
			: "0"(splitter02x), "1"(state2), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult2), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state1)
			: "0"(state1), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state2)
			: "0"(state2), [predResult] "r"(predicateResult2), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	TValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(TValueType));
		currentPos += bucketSize[currentBucket];
	}
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSort3Splitters1OversamplingFactor3BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc);
	}
}
template <typename TValueType, typename TKey>
static inline
void SampleSort3Splitters1OversamplingFactor4BlockSize(
	TValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(TValueType*,size_t),
	bool(*predicateLess)(TKey&,TValueType&),
	TKey(*getKeyFunc)(TValueType&))
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	TKey splitters[3];
	Find3Splitters1OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	register TKey splitter0 = splitters[0];
	register TKey splitter1 = splitters[1];
	register TKey splitter2 = splitters[2];
	
	TValueType *rawbuckets = (TValueType*) malloc(sizeof(TValueType) * 4 * elementCount);
	TValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	register int state0;
	register int predicateResult0;
	register TKey splitter00x;
	register int state1;
	register int predicateResult1;
	register TKey splitter01x;
	register int state2;
	register int predicateResult2;
	register TKey splitter02x;
	register int state3;
	register int predicateResult3;
	register TKey splitter03x;
	
	int max = elementCount - 4;
	int current = 0;
	register int zero = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 4)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		state1 = 0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		splitter01x = splitter0;
		state2 = 0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		splitter02x = splitter0;
		state3 = 0;
		predicateResult3 = (int) predicateLess(splitter1, A[current + 3]);
		splitter03x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter01x), [state] "=&r"(state1)
			: "0"(splitter01x), "1"(state1), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter02x), [state] "=&r"(state2)
			: "0"(splitter02x), "1"(state2), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult2), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter03x), [state] "=&r"(state3)
			: "0"(splitter03x), "1"(state3), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult3), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		predicateResult3 = (int) predicateLess(splitter03x, A[current + 3]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state1)
			: "0"(state1), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state2)
			: "0"(state2), [predResult] "r"(predicateResult2), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state3)
			: "0"(state3), [predResult] "r"(predicateResult3), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
		*buckets[state3] = A[current + 3];
		buckets[state3]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	TValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(TValueType));
		currentPos += bucketSize[currentBucket];
	}
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSort3Splitters1OversamplingFactor4BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc);
	}
}
template <typename TValueType, typename TKey>
static inline
void SampleSort3Splitters1OversamplingFactor5BlockSize(
	TValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(TValueType*,size_t),
	bool(*predicateLess)(TKey&,TValueType&),
	TKey(*getKeyFunc)(TValueType&))
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	TKey splitters[3];
	Find3Splitters1OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	register TKey splitter0 = splitters[0];
	register TKey splitter1 = splitters[1];
	register TKey splitter2 = splitters[2];
	
	TValueType *rawbuckets = (TValueType*) malloc(sizeof(TValueType) * 4 * elementCount);
	TValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	register int state0;
	register int predicateResult0;
	register TKey splitter00x;
	register int state1;
	register int predicateResult1;
	register TKey splitter01x;
	register int state2;
	register int predicateResult2;
	register TKey splitter02x;
	register int state3;
	register int predicateResult3;
	register TKey splitter03x;
	register int state4;
	register int predicateResult4;
	register TKey splitter04x;
	
	int max = elementCount - 5;
	int current = 0;
	register int zero = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 5)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		state1 = 0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		splitter01x = splitter0;
		state2 = 0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		splitter02x = splitter0;
		state3 = 0;
		predicateResult3 = (int) predicateLess(splitter1, A[current + 3]);
		splitter03x = splitter0;
		state4 = 0;
		predicateResult4 = (int) predicateLess(splitter1, A[current + 4]);
		splitter04x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter01x), [state] "=&r"(state1)
			: "0"(splitter01x), "1"(state1), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter02x), [state] "=&r"(state2)
			: "0"(splitter02x), "1"(state2), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult2), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter03x), [state] "=&r"(state3)
			: "0"(splitter03x), "1"(state3), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult3), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter04x), [state] "=&r"(state4)
			: "0"(splitter04x), "1"(state4), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult4), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		predicateResult3 = (int) predicateLess(splitter03x, A[current + 3]);
		predicateResult4 = (int) predicateLess(splitter04x, A[current + 4]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state1)
			: "0"(state1), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state2)
			: "0"(state2), [predResult] "r"(predicateResult2), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state3)
			: "0"(state3), [predResult] "r"(predicateResult3), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state4)
			: "0"(state4), [predResult] "r"(predicateResult4), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
		*buckets[state3] = A[current + 3];
		buckets[state3]++;
		*buckets[state4] = A[current + 4];
		buckets[state4]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	TValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(TValueType));
		currentPos += bucketSize[currentBucket];
	}
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSort3Splitters1OversamplingFactor5BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc);
	}
}
template <typename TValueType, typename TKey>
static inline
void Find3Splitters2OversamplingFactor(
	TValueType* items,
	size_t elementCount,
	TKey* splitterDestination,
	void(*sortFunc)(TValueType*,size_t),
	TKey(*getKeyFunc)(TValueType&))
{
	TValueType sample[6];
	int blockSize = elementCount / 6;
	for (int i = 0; i < 6; i += 1)
	{
		sample[i] = items[i * blockSize];
	}
	sortFunc(sample, 6);
	
	for (int i = 0; i < 3; i += 1)
	{
		splitterDestination[i] = getKeyFunc(sample[i * 2 + 1]);
	}
}
template <typename TValueType, typename TKey>
static inline
void SampleSort3Splitters2OversamplingFactor1BlockSize(
	TValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(TValueType*,size_t),
	bool(*predicateLess)(TKey&,TValueType&),
	TKey(*getKeyFunc)(TValueType&))
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	TKey splitters[3];
	Find3Splitters2OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	register TKey splitter0 = splitters[0];
	register TKey splitter1 = splitters[1];
	register TKey splitter2 = splitters[2];
	
	TValueType *rawbuckets = (TValueType*) malloc(sizeof(TValueType) * 4 * elementCount);
	TValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	register int state0;
	register int predicateResult0;
	register TKey splitter00x;
	
	int max = elementCount - 1;
	int current = 0;
	register int zero = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 1)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	TValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(TValueType));
		currentPos += bucketSize[currentBucket];
	}
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSort3Splitters2OversamplingFactor1BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc);
	}
}
template <typename TValueType, typename TKey>
static inline
void SampleSort3Splitters2OversamplingFactor2BlockSize(
	TValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(TValueType*,size_t),
	bool(*predicateLess)(TKey&,TValueType&),
	TKey(*getKeyFunc)(TValueType&))
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	TKey splitters[3];
	Find3Splitters2OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	register TKey splitter0 = splitters[0];
	register TKey splitter1 = splitters[1];
	register TKey splitter2 = splitters[2];
	
	TValueType *rawbuckets = (TValueType*) malloc(sizeof(TValueType) * 4 * elementCount);
	TValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	register int state0;
	register int predicateResult0;
	register TKey splitter00x;
	register int state1;
	register int predicateResult1;
	register TKey splitter01x;
	
	int max = elementCount - 2;
	int current = 0;
	register int zero = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 2)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		state1 = 0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		splitter01x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter01x), [state] "=&r"(state1)
			: "0"(splitter01x), "1"(state1), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state1)
			: "0"(state1), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	TValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(TValueType));
		currentPos += bucketSize[currentBucket];
	}
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSort3Splitters2OversamplingFactor2BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc);
	}
}
template <typename TValueType, typename TKey>
static inline
void SampleSort3Splitters2OversamplingFactor3BlockSize(
	TValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(TValueType*,size_t),
	bool(*predicateLess)(TKey&,TValueType&),
	TKey(*getKeyFunc)(TValueType&))
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	TKey splitters[3];
	Find3Splitters2OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	register TKey splitter0 = splitters[0];
	register TKey splitter1 = splitters[1];
	register TKey splitter2 = splitters[2];
	
	TValueType *rawbuckets = (TValueType*) malloc(sizeof(TValueType) * 4 * elementCount);
	TValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	register int state0;
	register int predicateResult0;
	register TKey splitter00x;
	register int state1;
	register int predicateResult1;
	register TKey splitter01x;
	register int state2;
	register int predicateResult2;
	register TKey splitter02x;
	
	int max = elementCount - 3;
	int current = 0;
	register int zero = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 3)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		state1 = 0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		splitter01x = splitter0;
		state2 = 0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		splitter02x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter01x), [state] "=&r"(state1)
			: "0"(splitter01x), "1"(state1), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter02x), [state] "=&r"(state2)
			: "0"(splitter02x), "1"(state2), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult2), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state1)
			: "0"(state1), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state2)
			: "0"(state2), [predResult] "r"(predicateResult2), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	TValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(TValueType));
		currentPos += bucketSize[currentBucket];
	}
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSort3Splitters2OversamplingFactor3BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc);
	}
}
template <typename TValueType, typename TKey>
static inline
void SampleSort3Splitters2OversamplingFactor4BlockSize(
	TValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(TValueType*,size_t),
	bool(*predicateLess)(TKey&,TValueType&),
	TKey(*getKeyFunc)(TValueType&))
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	TKey splitters[3];
	Find3Splitters2OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	register TKey splitter0 = splitters[0];
	register TKey splitter1 = splitters[1];
	register TKey splitter2 = splitters[2];
	
	TValueType *rawbuckets = (TValueType*) malloc(sizeof(TValueType) * 4 * elementCount);
	TValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	register int state0;
	register int predicateResult0;
	register TKey splitter00x;
	register int state1;
	register int predicateResult1;
	register TKey splitter01x;
	register int state2;
	register int predicateResult2;
	register TKey splitter02x;
	register int state3;
	register int predicateResult3;
	register TKey splitter03x;
	
	int max = elementCount - 4;
	int current = 0;
	register int zero = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 4)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		state1 = 0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		splitter01x = splitter0;
		state2 = 0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		splitter02x = splitter0;
		state3 = 0;
		predicateResult3 = (int) predicateLess(splitter1, A[current + 3]);
		splitter03x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter01x), [state] "=&r"(state1)
			: "0"(splitter01x), "1"(state1), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter02x), [state] "=&r"(state2)
			: "0"(splitter02x), "1"(state2), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult2), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter03x), [state] "=&r"(state3)
			: "0"(splitter03x), "1"(state3), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult3), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		predicateResult3 = (int) predicateLess(splitter03x, A[current + 3]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state1)
			: "0"(state1), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state2)
			: "0"(state2), [predResult] "r"(predicateResult2), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state3)
			: "0"(state3), [predResult] "r"(predicateResult3), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
		*buckets[state3] = A[current + 3];
		buckets[state3]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	TValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(TValueType));
		currentPos += bucketSize[currentBucket];
	}
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSort3Splitters2OversamplingFactor4BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc);
	}
}
template <typename TValueType, typename TKey>
static inline
void SampleSort3Splitters2OversamplingFactor5BlockSize(
	TValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(TValueType*,size_t),
	bool(*predicateLess)(TKey&,TValueType&),
	TKey(*getKeyFunc)(TValueType&))
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	TKey splitters[3];
	Find3Splitters2OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	register TKey splitter0 = splitters[0];
	register TKey splitter1 = splitters[1];
	register TKey splitter2 = splitters[2];
	
	TValueType *rawbuckets = (TValueType*) malloc(sizeof(TValueType) * 4 * elementCount);
	TValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	register int state0;
	register int predicateResult0;
	register TKey splitter00x;
	register int state1;
	register int predicateResult1;
	register TKey splitter01x;
	register int state2;
	register int predicateResult2;
	register TKey splitter02x;
	register int state3;
	register int predicateResult3;
	register TKey splitter03x;
	register int state4;
	register int predicateResult4;
	register TKey splitter04x;
	
	int max = elementCount - 5;
	int current = 0;
	register int zero = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 5)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		state1 = 0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		splitter01x = splitter0;
		state2 = 0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		splitter02x = splitter0;
		state3 = 0;
		predicateResult3 = (int) predicateLess(splitter1, A[current + 3]);
		splitter03x = splitter0;
		state4 = 0;
		predicateResult4 = (int) predicateLess(splitter1, A[current + 4]);
		splitter04x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter01x), [state] "=&r"(state1)
			: "0"(splitter01x), "1"(state1), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter02x), [state] "=&r"(state2)
			: "0"(splitter02x), "1"(state2), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult2), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter03x), [state] "=&r"(state3)
			: "0"(splitter03x), "1"(state3), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult3), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter04x), [state] "=&r"(state4)
			: "0"(splitter04x), "1"(state4), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult4), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		predicateResult3 = (int) predicateLess(splitter03x, A[current + 3]);
		predicateResult4 = (int) predicateLess(splitter04x, A[current + 4]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state1)
			: "0"(state1), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state2)
			: "0"(state2), [predResult] "r"(predicateResult2), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state3)
			: "0"(state3), [predResult] "r"(predicateResult3), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state4)
			: "0"(state4), [predResult] "r"(predicateResult4), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
		*buckets[state3] = A[current + 3];
		buckets[state3]++;
		*buckets[state4] = A[current + 4];
		buckets[state4]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	TValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(TValueType));
		currentPos += bucketSize[currentBucket];
	}
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSort3Splitters2OversamplingFactor5BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc);
	}
}
template <typename TValueType, typename TKey>
static inline
void Find3Splitters3OversamplingFactor(
	TValueType* items,
	size_t elementCount,
	TKey* splitterDestination,
	void(*sortFunc)(TValueType*,size_t),
	TKey(*getKeyFunc)(TValueType&))
{
	TValueType sample[9];
	int blockSize = elementCount / 9;
	for (int i = 0; i < 9; i += 1)
	{
		sample[i] = items[i * blockSize];
	}
	sortFunc(sample, 9);
	
	for (int i = 0; i < 3; i += 1)
	{
		splitterDestination[i] = getKeyFunc(sample[i * 3 + 1]);
	}
}
template <typename TValueType, typename TKey>
static inline
void SampleSort3Splitters3OversamplingFactor1BlockSize(
	TValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(TValueType*,size_t),
	bool(*predicateLess)(TKey&,TValueType&),
	TKey(*getKeyFunc)(TValueType&))
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	TKey splitters[3];
	Find3Splitters3OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	register TKey splitter0 = splitters[0];
	register TKey splitter1 = splitters[1];
	register TKey splitter2 = splitters[2];
	
	TValueType *rawbuckets = (TValueType*) malloc(sizeof(TValueType) * 4 * elementCount);
	TValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	register int state0;
	register int predicateResult0;
	register TKey splitter00x;
	
	int max = elementCount - 1;
	int current = 0;
	register int zero = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 1)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	TValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(TValueType));
		currentPos += bucketSize[currentBucket];
	}
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSort3Splitters3OversamplingFactor1BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc);
	}
}
template <typename TValueType, typename TKey>
static inline
void SampleSort3Splitters3OversamplingFactor2BlockSize(
	TValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(TValueType*,size_t),
	bool(*predicateLess)(TKey&,TValueType&),
	TKey(*getKeyFunc)(TValueType&))
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	TKey splitters[3];
	Find3Splitters3OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	register TKey splitter0 = splitters[0];
	register TKey splitter1 = splitters[1];
	register TKey splitter2 = splitters[2];
	
	TValueType *rawbuckets = (TValueType*) malloc(sizeof(TValueType) * 4 * elementCount);
	TValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	register int state0;
	register int predicateResult0;
	register TKey splitter00x;
	register int state1;
	register int predicateResult1;
	register TKey splitter01x;
	
	int max = elementCount - 2;
	int current = 0;
	register int zero = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 2)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		state1 = 0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		splitter01x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter01x), [state] "=&r"(state1)
			: "0"(splitter01x), "1"(state1), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state1)
			: "0"(state1), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	TValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(TValueType));
		currentPos += bucketSize[currentBucket];
	}
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSort3Splitters3OversamplingFactor2BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc);
	}
}
template <typename TValueType, typename TKey>
static inline
void SampleSort3Splitters3OversamplingFactor3BlockSize(
	TValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(TValueType*,size_t),
	bool(*predicateLess)(TKey&,TValueType&),
	TKey(*getKeyFunc)(TValueType&))
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	TKey splitters[3];
	Find3Splitters3OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	register TKey splitter0 = splitters[0];
	register TKey splitter1 = splitters[1];
	register TKey splitter2 = splitters[2];
	
	TValueType *rawbuckets = (TValueType*) malloc(sizeof(TValueType) * 4 * elementCount);
	TValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	register int state0;
	register int predicateResult0;
	register TKey splitter00x;
	register int state1;
	register int predicateResult1;
	register TKey splitter01x;
	register int state2;
	register int predicateResult2;
	register TKey splitter02x;
	
	int max = elementCount - 3;
	int current = 0;
	register int zero = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 3)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		state1 = 0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		splitter01x = splitter0;
		state2 = 0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		splitter02x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter01x), [state] "=&r"(state1)
			: "0"(splitter01x), "1"(state1), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter02x), [state] "=&r"(state2)
			: "0"(splitter02x), "1"(state2), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult2), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state1)
			: "0"(state1), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state2)
			: "0"(state2), [predResult] "r"(predicateResult2), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	TValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(TValueType));
		currentPos += bucketSize[currentBucket];
	}
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSort3Splitters3OversamplingFactor3BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc);
	}
}
template <typename TValueType, typename TKey>
static inline
void SampleSort3Splitters3OversamplingFactor4BlockSize(
	TValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(TValueType*,size_t),
	bool(*predicateLess)(TKey&,TValueType&),
	TKey(*getKeyFunc)(TValueType&))
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	TKey splitters[3];
	Find3Splitters3OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	register TKey splitter0 = splitters[0];
	register TKey splitter1 = splitters[1];
	register TKey splitter2 = splitters[2];
	
	TValueType *rawbuckets = (TValueType*) malloc(sizeof(TValueType) * 4 * elementCount);
	TValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	register int state0;
	register int predicateResult0;
	register TKey splitter00x;
	register int state1;
	register int predicateResult1;
	register TKey splitter01x;
	register int state2;
	register int predicateResult2;
	register TKey splitter02x;
	register int state3;
	register int predicateResult3;
	register TKey splitter03x;
	
	int max = elementCount - 4;
	int current = 0;
	register int zero = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 4)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		state1 = 0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		splitter01x = splitter0;
		state2 = 0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		splitter02x = splitter0;
		state3 = 0;
		predicateResult3 = (int) predicateLess(splitter1, A[current + 3]);
		splitter03x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter01x), [state] "=&r"(state1)
			: "0"(splitter01x), "1"(state1), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter02x), [state] "=&r"(state2)
			: "0"(splitter02x), "1"(state2), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult2), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter03x), [state] "=&r"(state3)
			: "0"(splitter03x), "1"(state3), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult3), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		predicateResult3 = (int) predicateLess(splitter03x, A[current + 3]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state1)
			: "0"(state1), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state2)
			: "0"(state2), [predResult] "r"(predicateResult2), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state3)
			: "0"(state3), [predResult] "r"(predicateResult3), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
		*buckets[state3] = A[current + 3];
		buckets[state3]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	TValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(TValueType));
		currentPos += bucketSize[currentBucket];
	}
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSort3Splitters3OversamplingFactor4BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc);
	}
}
template <typename TValueType, typename TKey>
static inline
void SampleSort3Splitters3OversamplingFactor5BlockSize(
	TValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(TValueType*,size_t),
	bool(*predicateLess)(TKey&,TValueType&),
	TKey(*getKeyFunc)(TValueType&))
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	TKey splitters[3];
	Find3Splitters3OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	register TKey splitter0 = splitters[0];
	register TKey splitter1 = splitters[1];
	register TKey splitter2 = splitters[2];
	
	TValueType *rawbuckets = (TValueType*) malloc(sizeof(TValueType) * 4 * elementCount);
	TValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	register int state0;
	register int predicateResult0;
	register TKey splitter00x;
	register int state1;
	register int predicateResult1;
	register TKey splitter01x;
	register int state2;
	register int predicateResult2;
	register TKey splitter02x;
	register int state3;
	register int predicateResult3;
	register TKey splitter03x;
	register int state4;
	register int predicateResult4;
	register TKey splitter04x;
	
	int max = elementCount - 5;
	int current = 0;
	register int zero = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 5)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		state1 = 0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		splitter01x = splitter0;
		state2 = 0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		splitter02x = splitter0;
		state3 = 0;
		predicateResult3 = (int) predicateLess(splitter1, A[current + 3]);
		splitter03x = splitter0;
		state4 = 0;
		predicateResult4 = (int) predicateLess(splitter1, A[current + 4]);
		splitter04x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter01x), [state] "=&r"(state1)
			: "0"(splitter01x), "1"(state1), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter02x), [state] "=&r"(state2)
			: "0"(splitter02x), "1"(state2), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult2), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter03x), [state] "=&r"(state3)
			: "0"(splitter03x), "1"(state3), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult3), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter04x), [state] "=&r"(state4)
			: "0"(splitter04x), "1"(state4), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult4), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		predicateResult3 = (int) predicateLess(splitter03x, A[current + 3]);
		predicateResult4 = (int) predicateLess(splitter04x, A[current + 4]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state1)
			: "0"(state1), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state2)
			: "0"(state2), [predResult] "r"(predicateResult2), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state3)
			: "0"(state3), [predResult] "r"(predicateResult3), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state4)
			: "0"(state4), [predResult] "r"(predicateResult4), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
		*buckets[state3] = A[current + 3];
		buckets[state3]++;
		*buckets[state4] = A[current + 4];
		buckets[state4]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	TValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(TValueType));
		currentPos += bucketSize[currentBucket];
	}
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSort3Splitters3OversamplingFactor5BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc);
	}
}
template <typename TValueType, typename TKey>
static inline
void Find3Splitters4OversamplingFactor(
	TValueType* items,
	size_t elementCount,
	TKey* splitterDestination,
	void(*sortFunc)(TValueType*,size_t),
	TKey(*getKeyFunc)(TValueType&))
{
	TValueType sample[12];
	int blockSize = elementCount / 12;
	for (int i = 0; i < 12; i += 1)
	{
		sample[i] = items[i * blockSize];
	}
	sortFunc(sample, 12);
	
	for (int i = 0; i < 3; i += 1)
	{
		splitterDestination[i] = getKeyFunc(sample[i * 4 + 2]);
	}
}
template <typename TValueType, typename TKey>
static inline
void SampleSort3Splitters4OversamplingFactor1BlockSize(
	TValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(TValueType*,size_t),
	bool(*predicateLess)(TKey&,TValueType&),
	TKey(*getKeyFunc)(TValueType&))
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	TKey splitters[3];
	Find3Splitters4OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	register TKey splitter0 = splitters[0];
	register TKey splitter1 = splitters[1];
	register TKey splitter2 = splitters[2];
	
	TValueType *rawbuckets = (TValueType*) malloc(sizeof(TValueType) * 4 * elementCount);
	TValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	register int state0;
	register int predicateResult0;
	register TKey splitter00x;
	
	int max = elementCount - 1;
	int current = 0;
	register int zero = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 1)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	TValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(TValueType));
		currentPos += bucketSize[currentBucket];
	}
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSort3Splitters4OversamplingFactor1BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc);
	}
}
template <typename TValueType, typename TKey>
static inline
void SampleSort3Splitters4OversamplingFactor2BlockSize(
	TValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(TValueType*,size_t),
	bool(*predicateLess)(TKey&,TValueType&),
	TKey(*getKeyFunc)(TValueType&))
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	TKey splitters[3];
	Find3Splitters4OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	register TKey splitter0 = splitters[0];
	register TKey splitter1 = splitters[1];
	register TKey splitter2 = splitters[2];
	
	TValueType *rawbuckets = (TValueType*) malloc(sizeof(TValueType) * 4 * elementCount);
	TValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	register int state0;
	register int predicateResult0;
	register TKey splitter00x;
	register int state1;
	register int predicateResult1;
	register TKey splitter01x;
	
	int max = elementCount - 2;
	int current = 0;
	register int zero = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 2)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		state1 = 0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		splitter01x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter01x), [state] "=&r"(state1)
			: "0"(splitter01x), "1"(state1), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state1)
			: "0"(state1), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	TValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(TValueType));
		currentPos += bucketSize[currentBucket];
	}
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSort3Splitters4OversamplingFactor2BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc);
	}
}
template <typename TValueType, typename TKey>
static inline
void SampleSort3Splitters4OversamplingFactor3BlockSize(
	TValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(TValueType*,size_t),
	bool(*predicateLess)(TKey&,TValueType&),
	TKey(*getKeyFunc)(TValueType&))
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	TKey splitters[3];
	Find3Splitters4OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	register TKey splitter0 = splitters[0];
	register TKey splitter1 = splitters[1];
	register TKey splitter2 = splitters[2];
	
	TValueType *rawbuckets = (TValueType*) malloc(sizeof(TValueType) * 4 * elementCount);
	TValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	register int state0;
	register int predicateResult0;
	register TKey splitter00x;
	register int state1;
	register int predicateResult1;
	register TKey splitter01x;
	register int state2;
	register int predicateResult2;
	register TKey splitter02x;
	
	int max = elementCount - 3;
	int current = 0;
	register int zero = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 3)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		state1 = 0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		splitter01x = splitter0;
		state2 = 0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		splitter02x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter01x), [state] "=&r"(state1)
			: "0"(splitter01x), "1"(state1), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter02x), [state] "=&r"(state2)
			: "0"(splitter02x), "1"(state2), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult2), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state1)
			: "0"(state1), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state2)
			: "0"(state2), [predResult] "r"(predicateResult2), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	TValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(TValueType));
		currentPos += bucketSize[currentBucket];
	}
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSort3Splitters4OversamplingFactor3BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc);
	}
}
template <typename TValueType, typename TKey>
static inline
void SampleSort3Splitters4OversamplingFactor4BlockSize(
	TValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(TValueType*,size_t),
	bool(*predicateLess)(TKey&,TValueType&),
	TKey(*getKeyFunc)(TValueType&))
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	TKey splitters[3];
	Find3Splitters4OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	register TKey splitter0 = splitters[0];
	register TKey splitter1 = splitters[1];
	register TKey splitter2 = splitters[2];
	
	TValueType *rawbuckets = (TValueType*) malloc(sizeof(TValueType) * 4 * elementCount);
	TValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	register int state0;
	register int predicateResult0;
	register TKey splitter00x;
	register int state1;
	register int predicateResult1;
	register TKey splitter01x;
	register int state2;
	register int predicateResult2;
	register TKey splitter02x;
	register int state3;
	register int predicateResult3;
	register TKey splitter03x;
	
	int max = elementCount - 4;
	int current = 0;
	register int zero = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 4)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		state1 = 0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		splitter01x = splitter0;
		state2 = 0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		splitter02x = splitter0;
		state3 = 0;
		predicateResult3 = (int) predicateLess(splitter1, A[current + 3]);
		splitter03x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter01x), [state] "=&r"(state1)
			: "0"(splitter01x), "1"(state1), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter02x), [state] "=&r"(state2)
			: "0"(splitter02x), "1"(state2), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult2), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter03x), [state] "=&r"(state3)
			: "0"(splitter03x), "1"(state3), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult3), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		predicateResult3 = (int) predicateLess(splitter03x, A[current + 3]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state1)
			: "0"(state1), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state2)
			: "0"(state2), [predResult] "r"(predicateResult2), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state3)
			: "0"(state3), [predResult] "r"(predicateResult3), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
		*buckets[state3] = A[current + 3];
		buckets[state3]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	TValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(TValueType));
		currentPos += bucketSize[currentBucket];
	}
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSort3Splitters4OversamplingFactor4BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc);
	}
}
template <typename TValueType, typename TKey>
static inline
void SampleSort3Splitters4OversamplingFactor5BlockSize(
	TValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(TValueType*,size_t),
	bool(*predicateLess)(TKey&,TValueType&),
	TKey(*getKeyFunc)(TValueType&))
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	TKey splitters[3];
	Find3Splitters4OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	register TKey splitter0 = splitters[0];
	register TKey splitter1 = splitters[1];
	register TKey splitter2 = splitters[2];
	
	TValueType *rawbuckets = (TValueType*) malloc(sizeof(TValueType) * 4 * elementCount);
	TValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	register int state0;
	register int predicateResult0;
	register TKey splitter00x;
	register int state1;
	register int predicateResult1;
	register TKey splitter01x;
	register int state2;
	register int predicateResult2;
	register TKey splitter02x;
	register int state3;
	register int predicateResult3;
	register TKey splitter03x;
	register int state4;
	register int predicateResult4;
	register TKey splitter04x;
	
	int max = elementCount - 5;
	int current = 0;
	register int zero = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 5)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		state1 = 0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		splitter01x = splitter0;
		state2 = 0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		splitter02x = splitter0;
		state3 = 0;
		predicateResult3 = (int) predicateLess(splitter1, A[current + 3]);
		splitter03x = splitter0;
		state4 = 0;
		predicateResult4 = (int) predicateLess(splitter1, A[current + 4]);
		splitter04x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter01x), [state] "=&r"(state1)
			: "0"(splitter01x), "1"(state1), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter02x), [state] "=&r"(state2)
			: "0"(splitter02x), "1"(state2), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult2), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter03x), [state] "=&r"(state3)
			: "0"(splitter03x), "1"(state3), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult3), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter04x), [state] "=&r"(state4)
			: "0"(splitter04x), "1"(state4), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult4), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		predicateResult3 = (int) predicateLess(splitter03x, A[current + 3]);
		predicateResult4 = (int) predicateLess(splitter04x, A[current + 4]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state1)
			: "0"(state1), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state2)
			: "0"(state2), [predResult] "r"(predicateResult2), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state3)
			: "0"(state3), [predResult] "r"(predicateResult3), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state4)
			: "0"(state4), [predResult] "r"(predicateResult4), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
		*buckets[state3] = A[current + 3];
		buckets[state3]++;
		*buckets[state4] = A[current + 4];
		buckets[state4]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	TValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(TValueType));
		currentPos += bucketSize[currentBucket];
	}
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSort3Splitters4OversamplingFactor5BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc);
	}
}
template <typename TValueType, typename TKey>
static inline
void Find3Splitters5OversamplingFactor(
	TValueType* items,
	size_t elementCount,
	TKey* splitterDestination,
	void(*sortFunc)(TValueType*,size_t),
	TKey(*getKeyFunc)(TValueType&))
{
	TValueType sample[15];
	int blockSize = elementCount / 15;
	for (int i = 0; i < 15; i += 1)
	{
		sample[i] = items[i * blockSize];
	}
	sortFunc(sample, 15);
	
	for (int i = 0; i < 3; i += 1)
	{
		splitterDestination[i] = getKeyFunc(sample[i * 5 + 2]);
	}
}
template <typename TValueType, typename TKey>
static inline
void SampleSort3Splitters5OversamplingFactor1BlockSize(
	TValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(TValueType*,size_t),
	bool(*predicateLess)(TKey&,TValueType&),
	TKey(*getKeyFunc)(TValueType&))
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	TKey splitters[3];
	Find3Splitters5OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	register TKey splitter0 = splitters[0];
	register TKey splitter1 = splitters[1];
	register TKey splitter2 = splitters[2];
	
	TValueType *rawbuckets = (TValueType*) malloc(sizeof(TValueType) * 4 * elementCount);
	TValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	register int state0;
	register int predicateResult0;
	register TKey splitter00x;
	
	int max = elementCount - 1;
	int current = 0;
	register int zero = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 1)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	TValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(TValueType));
		currentPos += bucketSize[currentBucket];
	}
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSort3Splitters5OversamplingFactor1BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc);
	}
}
template <typename TValueType, typename TKey>
static inline
void SampleSort3Splitters5OversamplingFactor2BlockSize(
	TValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(TValueType*,size_t),
	bool(*predicateLess)(TKey&,TValueType&),
	TKey(*getKeyFunc)(TValueType&))
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	TKey splitters[3];
	Find3Splitters5OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	register TKey splitter0 = splitters[0];
	register TKey splitter1 = splitters[1];
	register TKey splitter2 = splitters[2];
	
	TValueType *rawbuckets = (TValueType*) malloc(sizeof(TValueType) * 4 * elementCount);
	TValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	register int state0;
	register int predicateResult0;
	register TKey splitter00x;
	register int state1;
	register int predicateResult1;
	register TKey splitter01x;
	
	int max = elementCount - 2;
	int current = 0;
	register int zero = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 2)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		state1 = 0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		splitter01x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter01x), [state] "=&r"(state1)
			: "0"(splitter01x), "1"(state1), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state1)
			: "0"(state1), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	TValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(TValueType));
		currentPos += bucketSize[currentBucket];
	}
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSort3Splitters5OversamplingFactor2BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc);
	}
}
template <typename TValueType, typename TKey>
static inline
void SampleSort3Splitters5OversamplingFactor3BlockSize(
	TValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(TValueType*,size_t),
	bool(*predicateLess)(TKey&,TValueType&),
	TKey(*getKeyFunc)(TValueType&))
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	TKey splitters[3];
	Find3Splitters5OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	register TKey splitter0 = splitters[0];
	register TKey splitter1 = splitters[1];
	register TKey splitter2 = splitters[2];
	
	TValueType *rawbuckets = (TValueType*) malloc(sizeof(TValueType) * 4 * elementCount);
	TValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	register int state0;
	register int predicateResult0;
	register TKey splitter00x;
	register int state1;
	register int predicateResult1;
	register TKey splitter01x;
	register int state2;
	register int predicateResult2;
	register TKey splitter02x;
	
	int max = elementCount - 3;
	int current = 0;
	register int zero = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 3)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		state1 = 0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		splitter01x = splitter0;
		state2 = 0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		splitter02x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter01x), [state] "=&r"(state1)
			: "0"(splitter01x), "1"(state1), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter02x), [state] "=&r"(state2)
			: "0"(splitter02x), "1"(state2), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult2), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state1)
			: "0"(state1), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state2)
			: "0"(state2), [predResult] "r"(predicateResult2), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	TValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(TValueType));
		currentPos += bucketSize[currentBucket];
	}
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSort3Splitters5OversamplingFactor3BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc);
	}
}
template <typename TValueType, typename TKey>
static inline
void SampleSort3Splitters5OversamplingFactor4BlockSize(
	TValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(TValueType*,size_t),
	bool(*predicateLess)(TKey&,TValueType&),
	TKey(*getKeyFunc)(TValueType&))
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	TKey splitters[3];
	Find3Splitters5OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	register TKey splitter0 = splitters[0];
	register TKey splitter1 = splitters[1];
	register TKey splitter2 = splitters[2];
	
	TValueType *rawbuckets = (TValueType*) malloc(sizeof(TValueType) * 4 * elementCount);
	TValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	register int state0;
	register int predicateResult0;
	register TKey splitter00x;
	register int state1;
	register int predicateResult1;
	register TKey splitter01x;
	register int state2;
	register int predicateResult2;
	register TKey splitter02x;
	register int state3;
	register int predicateResult3;
	register TKey splitter03x;
	
	int max = elementCount - 4;
	int current = 0;
	register int zero = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 4)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		state1 = 0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		splitter01x = splitter0;
		state2 = 0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		splitter02x = splitter0;
		state3 = 0;
		predicateResult3 = (int) predicateLess(splitter1, A[current + 3]);
		splitter03x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter01x), [state] "=&r"(state1)
			: "0"(splitter01x), "1"(state1), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter02x), [state] "=&r"(state2)
			: "0"(splitter02x), "1"(state2), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult2), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter03x), [state] "=&r"(state3)
			: "0"(splitter03x), "1"(state3), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult3), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		predicateResult3 = (int) predicateLess(splitter03x, A[current + 3]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state1)
			: "0"(state1), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state2)
			: "0"(state2), [predResult] "r"(predicateResult2), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state3)
			: "0"(state3), [predResult] "r"(predicateResult3), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
		*buckets[state3] = A[current + 3];
		buckets[state3]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	TValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(TValueType));
		currentPos += bucketSize[currentBucket];
	}
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSort3Splitters5OversamplingFactor4BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc);
	}
}
template <typename TValueType, typename TKey>
static inline
void SampleSort3Splitters5OversamplingFactor5BlockSize(
	TValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(TValueType*,size_t),
	bool(*predicateLess)(TKey&,TValueType&),
	TKey(*getKeyFunc)(TValueType&))
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	TKey splitters[3];
	Find3Splitters5OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	register TKey splitter0 = splitters[0];
	register TKey splitter1 = splitters[1];
	register TKey splitter2 = splitters[2];
	
	TValueType *rawbuckets = (TValueType*) malloc(sizeof(TValueType) * 4 * elementCount);
	TValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	register int state0;
	register int predicateResult0;
	register TKey splitter00x;
	register int state1;
	register int predicateResult1;
	register TKey splitter01x;
	register int state2;
	register int predicateResult2;
	register TKey splitter02x;
	register int state3;
	register int predicateResult3;
	register TKey splitter03x;
	register int state4;
	register int predicateResult4;
	register TKey splitter04x;
	
	int max = elementCount - 5;
	int current = 0;
	register int zero = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 5)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		state1 = 0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		splitter01x = splitter0;
		state2 = 0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		splitter02x = splitter0;
		state3 = 0;
		predicateResult3 = (int) predicateLess(splitter1, A[current + 3]);
		splitter03x = splitter0;
		state4 = 0;
		predicateResult4 = (int) predicateLess(splitter1, A[current + 4]);
		splitter04x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter01x), [state] "=&r"(state1)
			: "0"(splitter01x), "1"(state1), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter02x), [state] "=&r"(state2)
			: "0"(splitter02x), "1"(state2), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult2), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter03x), [state] "=&r"(state3)
			: "0"(splitter03x), "1"(state3), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult3), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter04x), [state] "=&r"(state4)
			: "0"(splitter04x), "1"(state4), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult4), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		predicateResult3 = (int) predicateLess(splitter03x, A[current + 3]);
		predicateResult4 = (int) predicateLess(splitter04x, A[current + 4]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state1)
			: "0"(state1), [predResult] "r"(predicateResult1), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state2)
			: "0"(state2), [predResult] "r"(predicateResult2), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state3)
			: "0"(state3), [predResult] "r"(predicateResult3), [zero] "r"(zero)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state4)
			: "0"(state4), [predResult] "r"(predicateResult4), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
		*buckets[state3] = A[current + 3];
		buckets[state3]++;
		*buckets[state4] = A[current + 4];
		buckets[state4]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		state0 = 0;
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "=&r"(splitter00x), [state] "=&r"(state0)
			: "0"(splitter00x), "1"(state0), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "=&r"(state0)
			: "0"(state0), [predResult] "r"(predicateResult0), [zero] "r"(zero)
			: "cc"
		);
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	TValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(TValueType));
		currentPos += bucketSize[currentBucket];
	}
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSort3Splitters5OversamplingFactor5BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc);
	}
}
}

#endif // SAMPLESORT_GENERATED_H
