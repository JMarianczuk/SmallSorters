




//------------------------------------------------------------------------------
// <auto-generated>
//     This code was auto-generated from a T4 template
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#ifndef SAMPLESORT_GENERATED_H
#define SAMPLESORT_GENERATED_H

#include <cstring>

template <typename TValueType>
static inline
void SampleSort3Splitters2BlockSize(TValueType* A, int elementCount, TValueType* splitters)
{
	register TValueType splitter0 = splitters[0];
	register TValueType splitter1 = splitters[1];
	register TValueType splitter2 = splitters[2];

	TValueType rawbuckets[4 * elementCount];
	TValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	register TValueType element0;
	register int state0;
	register TValueType splitter00x;
	register TValueType element1;
	register int state1;
	register TValueType splitter01x;

	int max = elementCount - 2;
	int current = 0;
	//Sort 2 elements simultaneously into the buckets
	for ( ; current <= max; current += 2)
	{
		element0 = A[current];
		state0 = 0;
		splitter00x = splitter0;
		element1 = A[current + 1];
		state1 = 0;
		splitter01x = splitter0;
		__asm__(
			"cmp %[ele],%[splitter1]\n\t"
			"cmovc %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "+r"(splitter00x), [state] "+r"(state0)
			: [ele] "r"(element0), [splitter1] "r"(splitter1), [splitter2] "r"(splitter2)
			: "cc"
		);
		__asm__(
			"cmp %[ele],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "+r"(state0)
			: [ele] "r"(element0), [splitterx] "r"(splitter00x)
			: "cc"
		);
		__asm__(
			"cmp %[ele],%[splitter1]\n\t"
			"cmovc %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "+r"(splitter01x), [state] "+r"(state1)
			: [ele] "r"(element1), [splitter1] "r"(splitter1), [splitter2] "r"(splitter2)
			: "cc"
		);
		__asm__(
			"cmp %[ele],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "+r"(state1)
			: [ele] "r"(element1), [splitterx] "r"(splitter01x)
			: "cc"
		);
		*buckets[state0] = element0;
		buckets[state0]++;
		*buckets[state1] = element1;
		buckets[state1]++;
	}

	//Sort the remaining k < 2 elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		element0 = A[current];
		state0 = 0;
		splitter00x = splitter0;
		__asm__(
			"cmp %[ele],%[splitter1]\n\t"
			"cmovc %[splitter2],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [splitterx] "+r"(splitter00x), [state] "+r"(state0)
			: [ele] "r"(element0), [splitter1] "r"(splitter1), [splitter2] "r"(splitter2)
			: "cc"
		);
		__asm__(
			"cmp %[ele],%[splitterx]\n\t"
			"rcl $1,%[state]\n\t"
			: [state] "+r"(state0)
			: [ele] "r"(element0), [splitterx] "r"(splitter00x)
			: "cc"
		);
		*buckets[state0] = element0;
		buckets[state0]++;
	}

	TValueType* currentPos = A;
	int bucketSize[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(TValueType));
		currentPos += bucketSize[currentBucket];
	}
}

#endif
