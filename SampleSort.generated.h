//------------------------------------------------------------------------------
// <auto-generated>
//     This code was auto-generated
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#ifndef SAMPLESORT_GENERATED_H
#define SAMPLESORT_GENERATED_H

#include <cstring>
#include <inttypes.h>

#include "InsertionSort.h"
#include "DebugHelper.h"
#include "CustomMath.h"
namespace samplesort
{
template <typename ValueType, typename TKey>
static inline
void Find3Splitters1OversamplingFactor(
	ValueType* items,
	size_t elementCount,
	TKey* splitterDestination,
	void(*sortFunc)(ValueType*,size_t),
	TKey(*getKeyFunc)(ValueType&))
{
	ValueType sample[3];
	int blockSize = elementCount / 3;
	for (int i = 0; i < 3; i += 1)
	{
		sample[i] = items[i * blockSize];
	}
	sortFunc(sample, 3);
	
	for (int i = 0; i < 3; i += 1)
	{
		splitterDestination[i] = getKeyFunc(sample[i * 1 + 0]);
	}
}
template <typename ValueType, typename TKey>
inline
void SampleSortInternal3Splitters1OversamplingFactor1BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	TKey splitters[3];
	Find3Splitters1OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	TKey splitter0 = splitters[0];
	TKey splitter1 = splitters[1];
	TKey splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	TKey splitter00x;
	
	int max = elementCount - 1;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters1OversamplingFactor1BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc, depthLimit - 1);
	}
}
template <typename ValueType, typename TKey>
void SampleSort3Splitters1OversamplingFactor1BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&))
{
	SampleSortInternal3Splitters1OversamplingFactor1BlockSize(A, elementCount, baseCaseLimit, sortFunc, predicateLess, getKeyFunc, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename ValueType, typename TKey>
inline
void SampleSortInternal3Splitters1OversamplingFactor2BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	TKey splitters[3];
	Find3Splitters1OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	TKey splitter0 = splitters[0];
	TKey splitter1 = splitters[1];
	TKey splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	TKey splitter00x;
	int state1;
	int predicateResult1;
	TKey splitter01x;
	
	int max = elementCount - 2;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 2)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter01x)
			: "0"(splitter01x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters1OversamplingFactor2BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc, depthLimit - 1);
	}
}
template <typename ValueType, typename TKey>
void SampleSort3Splitters1OversamplingFactor2BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&))
{
	SampleSortInternal3Splitters1OversamplingFactor2BlockSize(A, elementCount, baseCaseLimit, sortFunc, predicateLess, getKeyFunc, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename ValueType, typename TKey>
inline
void SampleSortInternal3Splitters1OversamplingFactor3BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	TKey splitters[3];
	Find3Splitters1OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	TKey splitter0 = splitters[0];
	TKey splitter1 = splitters[1];
	TKey splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	TKey splitter00x;
	int state1;
	int predicateResult1;
	TKey splitter01x;
	int state2;
	int predicateResult2;
	TKey splitter02x;
	
	int max = elementCount - 3;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 3)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		state2 = predicateResult2;
		splitter02x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter01x)
			: "0"(splitter01x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter02x)
			: "0"(splitter02x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult2), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		state2 = (state2 << 1) + predicateResult2;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters1OversamplingFactor3BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc, depthLimit - 1);
	}
}
template <typename ValueType, typename TKey>
void SampleSort3Splitters1OversamplingFactor3BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&))
{
	SampleSortInternal3Splitters1OversamplingFactor3BlockSize(A, elementCount, baseCaseLimit, sortFunc, predicateLess, getKeyFunc, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename ValueType, typename TKey>
inline
void SampleSortInternal3Splitters1OversamplingFactor4BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	TKey splitters[3];
	Find3Splitters1OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	TKey splitter0 = splitters[0];
	TKey splitter1 = splitters[1];
	TKey splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	TKey splitter00x;
	int state1;
	int predicateResult1;
	TKey splitter01x;
	int state2;
	int predicateResult2;
	TKey splitter02x;
	int state3;
	int predicateResult3;
	TKey splitter03x;
	
	int max = elementCount - 4;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 4)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		state2 = predicateResult2;
		splitter02x = splitter0;
		predicateResult3 = (int) predicateLess(splitter1, A[current + 3]);
		state3 = predicateResult3;
		splitter03x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter01x)
			: "0"(splitter01x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter02x)
			: "0"(splitter02x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult2), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter03x)
			: "0"(splitter03x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult3), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		predicateResult3 = (int) predicateLess(splitter03x, A[current + 3]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		state2 = (state2 << 1) + predicateResult2;
		state3 = (state3 << 1) + predicateResult3;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
		*buckets[state3] = A[current + 3];
		buckets[state3]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters1OversamplingFactor4BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc, depthLimit - 1);
	}
}
template <typename ValueType, typename TKey>
void SampleSort3Splitters1OversamplingFactor4BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&))
{
	SampleSortInternal3Splitters1OversamplingFactor4BlockSize(A, elementCount, baseCaseLimit, sortFunc, predicateLess, getKeyFunc, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename ValueType, typename TKey>
inline
void SampleSortInternal3Splitters1OversamplingFactor5BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	TKey splitters[3];
	Find3Splitters1OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	TKey splitter0 = splitters[0];
	TKey splitter1 = splitters[1];
	TKey splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	TKey splitter00x;
	int state1;
	int predicateResult1;
	TKey splitter01x;
	int state2;
	int predicateResult2;
	TKey splitter02x;
	int state3;
	int predicateResult3;
	TKey splitter03x;
	int state4;
	int predicateResult4;
	TKey splitter04x;
	
	int max = elementCount - 5;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 5)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		state2 = predicateResult2;
		splitter02x = splitter0;
		predicateResult3 = (int) predicateLess(splitter1, A[current + 3]);
		state3 = predicateResult3;
		splitter03x = splitter0;
		predicateResult4 = (int) predicateLess(splitter1, A[current + 4]);
		state4 = predicateResult4;
		splitter04x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter01x)
			: "0"(splitter01x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter02x)
			: "0"(splitter02x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult2), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter03x)
			: "0"(splitter03x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult3), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter04x)
			: "0"(splitter04x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult4), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		predicateResult3 = (int) predicateLess(splitter03x, A[current + 3]);
		predicateResult4 = (int) predicateLess(splitter04x, A[current + 4]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		state2 = (state2 << 1) + predicateResult2;
		state3 = (state3 << 1) + predicateResult3;
		state4 = (state4 << 1) + predicateResult4;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
		*buckets[state3] = A[current + 3];
		buckets[state3]++;
		*buckets[state4] = A[current + 4];
		buckets[state4]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters1OversamplingFactor5BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc, depthLimit - 1);
	}
}
template <typename ValueType, typename TKey>
void SampleSort3Splitters1OversamplingFactor5BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&))
{
	SampleSortInternal3Splitters1OversamplingFactor5BlockSize(A, elementCount, baseCaseLimit, sortFunc, predicateLess, getKeyFunc, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename ValueType, typename TKey>
static inline
void Find3Splitters2OversamplingFactor(
	ValueType* items,
	size_t elementCount,
	TKey* splitterDestination,
	void(*sortFunc)(ValueType*,size_t),
	TKey(*getKeyFunc)(ValueType&))
{
	ValueType sample[6];
	int blockSize = elementCount / 6;
	for (int i = 0; i < 6; i += 1)
	{
		sample[i] = items[i * blockSize];
	}
	sortFunc(sample, 6);
	
	for (int i = 0; i < 3; i += 1)
	{
		splitterDestination[i] = getKeyFunc(sample[i * 2 + 1]);
	}
}
template <typename ValueType, typename TKey>
inline
void SampleSortInternal3Splitters2OversamplingFactor1BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	TKey splitters[3];
	Find3Splitters2OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	TKey splitter0 = splitters[0];
	TKey splitter1 = splitters[1];
	TKey splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	TKey splitter00x;
	
	int max = elementCount - 1;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters2OversamplingFactor1BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc, depthLimit - 1);
	}
}
template <typename ValueType, typename TKey>
void SampleSort3Splitters2OversamplingFactor1BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&))
{
	SampleSortInternal3Splitters2OversamplingFactor1BlockSize(A, elementCount, baseCaseLimit, sortFunc, predicateLess, getKeyFunc, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename ValueType, typename TKey>
inline
void SampleSortInternal3Splitters2OversamplingFactor2BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	TKey splitters[3];
	Find3Splitters2OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	TKey splitter0 = splitters[0];
	TKey splitter1 = splitters[1];
	TKey splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	TKey splitter00x;
	int state1;
	int predicateResult1;
	TKey splitter01x;
	
	int max = elementCount - 2;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 2)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter01x)
			: "0"(splitter01x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters2OversamplingFactor2BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc, depthLimit - 1);
	}
}
template <typename ValueType, typename TKey>
void SampleSort3Splitters2OversamplingFactor2BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&))
{
	SampleSortInternal3Splitters2OversamplingFactor2BlockSize(A, elementCount, baseCaseLimit, sortFunc, predicateLess, getKeyFunc, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename ValueType, typename TKey>
inline
void SampleSortInternal3Splitters2OversamplingFactor3BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	TKey splitters[3];
	Find3Splitters2OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	TKey splitter0 = splitters[0];
	TKey splitter1 = splitters[1];
	TKey splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	TKey splitter00x;
	int state1;
	int predicateResult1;
	TKey splitter01x;
	int state2;
	int predicateResult2;
	TKey splitter02x;
	
	int max = elementCount - 3;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 3)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		state2 = predicateResult2;
		splitter02x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter01x)
			: "0"(splitter01x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter02x)
			: "0"(splitter02x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult2), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		state2 = (state2 << 1) + predicateResult2;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters2OversamplingFactor3BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc, depthLimit - 1);
	}
}
template <typename ValueType, typename TKey>
void SampleSort3Splitters2OversamplingFactor3BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&))
{
	SampleSortInternal3Splitters2OversamplingFactor3BlockSize(A, elementCount, baseCaseLimit, sortFunc, predicateLess, getKeyFunc, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename ValueType, typename TKey>
inline
void SampleSortInternal3Splitters2OversamplingFactor4BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	TKey splitters[3];
	Find3Splitters2OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	TKey splitter0 = splitters[0];
	TKey splitter1 = splitters[1];
	TKey splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	TKey splitter00x;
	int state1;
	int predicateResult1;
	TKey splitter01x;
	int state2;
	int predicateResult2;
	TKey splitter02x;
	int state3;
	int predicateResult3;
	TKey splitter03x;
	
	int max = elementCount - 4;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 4)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		state2 = predicateResult2;
		splitter02x = splitter0;
		predicateResult3 = (int) predicateLess(splitter1, A[current + 3]);
		state3 = predicateResult3;
		splitter03x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter01x)
			: "0"(splitter01x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter02x)
			: "0"(splitter02x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult2), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter03x)
			: "0"(splitter03x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult3), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		predicateResult3 = (int) predicateLess(splitter03x, A[current + 3]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		state2 = (state2 << 1) + predicateResult2;
		state3 = (state3 << 1) + predicateResult3;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
		*buckets[state3] = A[current + 3];
		buckets[state3]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters2OversamplingFactor4BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc, depthLimit - 1);
	}
}
template <typename ValueType, typename TKey>
void SampleSort3Splitters2OversamplingFactor4BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&))
{
	SampleSortInternal3Splitters2OversamplingFactor4BlockSize(A, elementCount, baseCaseLimit, sortFunc, predicateLess, getKeyFunc, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename ValueType, typename TKey>
inline
void SampleSortInternal3Splitters2OversamplingFactor5BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	TKey splitters[3];
	Find3Splitters2OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	TKey splitter0 = splitters[0];
	TKey splitter1 = splitters[1];
	TKey splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	TKey splitter00x;
	int state1;
	int predicateResult1;
	TKey splitter01x;
	int state2;
	int predicateResult2;
	TKey splitter02x;
	int state3;
	int predicateResult3;
	TKey splitter03x;
	int state4;
	int predicateResult4;
	TKey splitter04x;
	
	int max = elementCount - 5;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 5)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		state2 = predicateResult2;
		splitter02x = splitter0;
		predicateResult3 = (int) predicateLess(splitter1, A[current + 3]);
		state3 = predicateResult3;
		splitter03x = splitter0;
		predicateResult4 = (int) predicateLess(splitter1, A[current + 4]);
		state4 = predicateResult4;
		splitter04x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter01x)
			: "0"(splitter01x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter02x)
			: "0"(splitter02x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult2), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter03x)
			: "0"(splitter03x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult3), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter04x)
			: "0"(splitter04x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult4), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		predicateResult3 = (int) predicateLess(splitter03x, A[current + 3]);
		predicateResult4 = (int) predicateLess(splitter04x, A[current + 4]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		state2 = (state2 << 1) + predicateResult2;
		state3 = (state3 << 1) + predicateResult3;
		state4 = (state4 << 1) + predicateResult4;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
		*buckets[state3] = A[current + 3];
		buckets[state3]++;
		*buckets[state4] = A[current + 4];
		buckets[state4]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters2OversamplingFactor5BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc, depthLimit - 1);
	}
}
template <typename ValueType, typename TKey>
void SampleSort3Splitters2OversamplingFactor5BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&))
{
	SampleSortInternal3Splitters2OversamplingFactor5BlockSize(A, elementCount, baseCaseLimit, sortFunc, predicateLess, getKeyFunc, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename ValueType, typename TKey>
static inline
void Find3Splitters3OversamplingFactor(
	ValueType* items,
	size_t elementCount,
	TKey* splitterDestination,
	void(*sortFunc)(ValueType*,size_t),
	TKey(*getKeyFunc)(ValueType&))
{
	ValueType sample[9];
	int blockSize = elementCount / 9;
	for (int i = 0; i < 9; i += 1)
	{
		sample[i] = items[i * blockSize];
	}
	sortFunc(sample, 9);
	
	for (int i = 0; i < 3; i += 1)
	{
		splitterDestination[i] = getKeyFunc(sample[i * 3 + 1]);
	}
}
template <typename ValueType, typename TKey>
inline
void SampleSortInternal3Splitters3OversamplingFactor1BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	TKey splitters[3];
	Find3Splitters3OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	TKey splitter0 = splitters[0];
	TKey splitter1 = splitters[1];
	TKey splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	TKey splitter00x;
	
	int max = elementCount - 1;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters3OversamplingFactor1BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc, depthLimit - 1);
	}
}
template <typename ValueType, typename TKey>
void SampleSort3Splitters3OversamplingFactor1BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&))
{
	SampleSortInternal3Splitters3OversamplingFactor1BlockSize(A, elementCount, baseCaseLimit, sortFunc, predicateLess, getKeyFunc, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename ValueType, typename TKey>
inline
void SampleSortInternal3Splitters3OversamplingFactor2BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	TKey splitters[3];
	Find3Splitters3OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	TKey splitter0 = splitters[0];
	TKey splitter1 = splitters[1];
	TKey splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	TKey splitter00x;
	int state1;
	int predicateResult1;
	TKey splitter01x;
	
	int max = elementCount - 2;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 2)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter01x)
			: "0"(splitter01x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters3OversamplingFactor2BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc, depthLimit - 1);
	}
}
template <typename ValueType, typename TKey>
void SampleSort3Splitters3OversamplingFactor2BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&))
{
	SampleSortInternal3Splitters3OversamplingFactor2BlockSize(A, elementCount, baseCaseLimit, sortFunc, predicateLess, getKeyFunc, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename ValueType, typename TKey>
inline
void SampleSortInternal3Splitters3OversamplingFactor3BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	TKey splitters[3];
	Find3Splitters3OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	TKey splitter0 = splitters[0];
	TKey splitter1 = splitters[1];
	TKey splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	TKey splitter00x;
	int state1;
	int predicateResult1;
	TKey splitter01x;
	int state2;
	int predicateResult2;
	TKey splitter02x;
	
	int max = elementCount - 3;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 3)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		state2 = predicateResult2;
		splitter02x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter01x)
			: "0"(splitter01x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter02x)
			: "0"(splitter02x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult2), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		state2 = (state2 << 1) + predicateResult2;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters3OversamplingFactor3BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc, depthLimit - 1);
	}
}
template <typename ValueType, typename TKey>
void SampleSort3Splitters3OversamplingFactor3BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&))
{
	SampleSortInternal3Splitters3OversamplingFactor3BlockSize(A, elementCount, baseCaseLimit, sortFunc, predicateLess, getKeyFunc, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename ValueType, typename TKey>
inline
void SampleSortInternal3Splitters3OversamplingFactor4BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	TKey splitters[3];
	Find3Splitters3OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	TKey splitter0 = splitters[0];
	TKey splitter1 = splitters[1];
	TKey splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	TKey splitter00x;
	int state1;
	int predicateResult1;
	TKey splitter01x;
	int state2;
	int predicateResult2;
	TKey splitter02x;
	int state3;
	int predicateResult3;
	TKey splitter03x;
	
	int max = elementCount - 4;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 4)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		state2 = predicateResult2;
		splitter02x = splitter0;
		predicateResult3 = (int) predicateLess(splitter1, A[current + 3]);
		state3 = predicateResult3;
		splitter03x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter01x)
			: "0"(splitter01x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter02x)
			: "0"(splitter02x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult2), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter03x)
			: "0"(splitter03x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult3), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		predicateResult3 = (int) predicateLess(splitter03x, A[current + 3]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		state2 = (state2 << 1) + predicateResult2;
		state3 = (state3 << 1) + predicateResult3;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
		*buckets[state3] = A[current + 3];
		buckets[state3]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters3OversamplingFactor4BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc, depthLimit - 1);
	}
}
template <typename ValueType, typename TKey>
void SampleSort3Splitters3OversamplingFactor4BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&))
{
	SampleSortInternal3Splitters3OversamplingFactor4BlockSize(A, elementCount, baseCaseLimit, sortFunc, predicateLess, getKeyFunc, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename ValueType, typename TKey>
inline
void SampleSortInternal3Splitters3OversamplingFactor5BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	TKey splitters[3];
	Find3Splitters3OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	TKey splitter0 = splitters[0];
	TKey splitter1 = splitters[1];
	TKey splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	TKey splitter00x;
	int state1;
	int predicateResult1;
	TKey splitter01x;
	int state2;
	int predicateResult2;
	TKey splitter02x;
	int state3;
	int predicateResult3;
	TKey splitter03x;
	int state4;
	int predicateResult4;
	TKey splitter04x;
	
	int max = elementCount - 5;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 5)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		state2 = predicateResult2;
		splitter02x = splitter0;
		predicateResult3 = (int) predicateLess(splitter1, A[current + 3]);
		state3 = predicateResult3;
		splitter03x = splitter0;
		predicateResult4 = (int) predicateLess(splitter1, A[current + 4]);
		state4 = predicateResult4;
		splitter04x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter01x)
			: "0"(splitter01x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter02x)
			: "0"(splitter02x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult2), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter03x)
			: "0"(splitter03x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult3), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter04x)
			: "0"(splitter04x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult4), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		predicateResult3 = (int) predicateLess(splitter03x, A[current + 3]);
		predicateResult4 = (int) predicateLess(splitter04x, A[current + 4]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		state2 = (state2 << 1) + predicateResult2;
		state3 = (state3 << 1) + predicateResult3;
		state4 = (state4 << 1) + predicateResult4;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
		*buckets[state3] = A[current + 3];
		buckets[state3]++;
		*buckets[state4] = A[current + 4];
		buckets[state4]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters3OversamplingFactor5BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc, depthLimit - 1);
	}
}
template <typename ValueType, typename TKey>
void SampleSort3Splitters3OversamplingFactor5BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&))
{
	SampleSortInternal3Splitters3OversamplingFactor5BlockSize(A, elementCount, baseCaseLimit, sortFunc, predicateLess, getKeyFunc, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename ValueType, typename TKey>
static inline
void Find3Splitters4OversamplingFactor(
	ValueType* items,
	size_t elementCount,
	TKey* splitterDestination,
	void(*sortFunc)(ValueType*,size_t),
	TKey(*getKeyFunc)(ValueType&))
{
	ValueType sample[12];
	int blockSize = elementCount / 12;
	for (int i = 0; i < 12; i += 1)
	{
		sample[i] = items[i * blockSize];
	}
	sortFunc(sample, 12);
	
	for (int i = 0; i < 3; i += 1)
	{
		splitterDestination[i] = getKeyFunc(sample[i * 4 + 2]);
	}
}
template <typename ValueType, typename TKey>
inline
void SampleSortInternal3Splitters4OversamplingFactor1BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	TKey splitters[3];
	Find3Splitters4OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	TKey splitter0 = splitters[0];
	TKey splitter1 = splitters[1];
	TKey splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	TKey splitter00x;
	
	int max = elementCount - 1;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters4OversamplingFactor1BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc, depthLimit - 1);
	}
}
template <typename ValueType, typename TKey>
void SampleSort3Splitters4OversamplingFactor1BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&))
{
	SampleSortInternal3Splitters4OversamplingFactor1BlockSize(A, elementCount, baseCaseLimit, sortFunc, predicateLess, getKeyFunc, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename ValueType, typename TKey>
inline
void SampleSortInternal3Splitters4OversamplingFactor2BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	TKey splitters[3];
	Find3Splitters4OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	TKey splitter0 = splitters[0];
	TKey splitter1 = splitters[1];
	TKey splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	TKey splitter00x;
	int state1;
	int predicateResult1;
	TKey splitter01x;
	
	int max = elementCount - 2;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 2)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter01x)
			: "0"(splitter01x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters4OversamplingFactor2BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc, depthLimit - 1);
	}
}
template <typename ValueType, typename TKey>
void SampleSort3Splitters4OversamplingFactor2BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&))
{
	SampleSortInternal3Splitters4OversamplingFactor2BlockSize(A, elementCount, baseCaseLimit, sortFunc, predicateLess, getKeyFunc, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename ValueType, typename TKey>
inline
void SampleSortInternal3Splitters4OversamplingFactor3BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	TKey splitters[3];
	Find3Splitters4OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	TKey splitter0 = splitters[0];
	TKey splitter1 = splitters[1];
	TKey splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	TKey splitter00x;
	int state1;
	int predicateResult1;
	TKey splitter01x;
	int state2;
	int predicateResult2;
	TKey splitter02x;
	
	int max = elementCount - 3;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 3)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		state2 = predicateResult2;
		splitter02x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter01x)
			: "0"(splitter01x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter02x)
			: "0"(splitter02x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult2), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		state2 = (state2 << 1) + predicateResult2;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters4OversamplingFactor3BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc, depthLimit - 1);
	}
}
template <typename ValueType, typename TKey>
void SampleSort3Splitters4OversamplingFactor3BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&))
{
	SampleSortInternal3Splitters4OversamplingFactor3BlockSize(A, elementCount, baseCaseLimit, sortFunc, predicateLess, getKeyFunc, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename ValueType, typename TKey>
inline
void SampleSortInternal3Splitters4OversamplingFactor4BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	TKey splitters[3];
	Find3Splitters4OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	TKey splitter0 = splitters[0];
	TKey splitter1 = splitters[1];
	TKey splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	TKey splitter00x;
	int state1;
	int predicateResult1;
	TKey splitter01x;
	int state2;
	int predicateResult2;
	TKey splitter02x;
	int state3;
	int predicateResult3;
	TKey splitter03x;
	
	int max = elementCount - 4;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 4)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		state2 = predicateResult2;
		splitter02x = splitter0;
		predicateResult3 = (int) predicateLess(splitter1, A[current + 3]);
		state3 = predicateResult3;
		splitter03x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter01x)
			: "0"(splitter01x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter02x)
			: "0"(splitter02x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult2), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter03x)
			: "0"(splitter03x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult3), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		predicateResult3 = (int) predicateLess(splitter03x, A[current + 3]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		state2 = (state2 << 1) + predicateResult2;
		state3 = (state3 << 1) + predicateResult3;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
		*buckets[state3] = A[current + 3];
		buckets[state3]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters4OversamplingFactor4BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc, depthLimit - 1);
	}
}
template <typename ValueType, typename TKey>
void SampleSort3Splitters4OversamplingFactor4BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&))
{
	SampleSortInternal3Splitters4OversamplingFactor4BlockSize(A, elementCount, baseCaseLimit, sortFunc, predicateLess, getKeyFunc, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename ValueType, typename TKey>
inline
void SampleSortInternal3Splitters4OversamplingFactor5BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	TKey splitters[3];
	Find3Splitters4OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	TKey splitter0 = splitters[0];
	TKey splitter1 = splitters[1];
	TKey splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	TKey splitter00x;
	int state1;
	int predicateResult1;
	TKey splitter01x;
	int state2;
	int predicateResult2;
	TKey splitter02x;
	int state3;
	int predicateResult3;
	TKey splitter03x;
	int state4;
	int predicateResult4;
	TKey splitter04x;
	
	int max = elementCount - 5;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 5)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		state2 = predicateResult2;
		splitter02x = splitter0;
		predicateResult3 = (int) predicateLess(splitter1, A[current + 3]);
		state3 = predicateResult3;
		splitter03x = splitter0;
		predicateResult4 = (int) predicateLess(splitter1, A[current + 4]);
		state4 = predicateResult4;
		splitter04x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter01x)
			: "0"(splitter01x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter02x)
			: "0"(splitter02x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult2), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter03x)
			: "0"(splitter03x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult3), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter04x)
			: "0"(splitter04x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult4), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		predicateResult3 = (int) predicateLess(splitter03x, A[current + 3]);
		predicateResult4 = (int) predicateLess(splitter04x, A[current + 4]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		state2 = (state2 << 1) + predicateResult2;
		state3 = (state3 << 1) + predicateResult3;
		state4 = (state4 << 1) + predicateResult4;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
		*buckets[state3] = A[current + 3];
		buckets[state3]++;
		*buckets[state4] = A[current + 4];
		buckets[state4]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters4OversamplingFactor5BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc, depthLimit - 1);
	}
}
template <typename ValueType, typename TKey>
void SampleSort3Splitters4OversamplingFactor5BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&))
{
	SampleSortInternal3Splitters4OversamplingFactor5BlockSize(A, elementCount, baseCaseLimit, sortFunc, predicateLess, getKeyFunc, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename ValueType, typename TKey>
static inline
void Find3Splitters5OversamplingFactor(
	ValueType* items,
	size_t elementCount,
	TKey* splitterDestination,
	void(*sortFunc)(ValueType*,size_t),
	TKey(*getKeyFunc)(ValueType&))
{
	ValueType sample[15];
	int blockSize = elementCount / 15;
	for (int i = 0; i < 15; i += 1)
	{
		sample[i] = items[i * blockSize];
	}
	sortFunc(sample, 15);
	
	for (int i = 0; i < 3; i += 1)
	{
		splitterDestination[i] = getKeyFunc(sample[i * 5 + 2]);
	}
}
template <typename ValueType, typename TKey>
inline
void SampleSortInternal3Splitters5OversamplingFactor1BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	TKey splitters[3];
	Find3Splitters5OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	TKey splitter0 = splitters[0];
	TKey splitter1 = splitters[1];
	TKey splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	TKey splitter00x;
	
	int max = elementCount - 1;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters5OversamplingFactor1BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc, depthLimit - 1);
	}
}
template <typename ValueType, typename TKey>
void SampleSort3Splitters5OversamplingFactor1BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&))
{
	SampleSortInternal3Splitters5OversamplingFactor1BlockSize(A, elementCount, baseCaseLimit, sortFunc, predicateLess, getKeyFunc, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename ValueType, typename TKey>
inline
void SampleSortInternal3Splitters5OversamplingFactor2BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	TKey splitters[3];
	Find3Splitters5OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	TKey splitter0 = splitters[0];
	TKey splitter1 = splitters[1];
	TKey splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	TKey splitter00x;
	int state1;
	int predicateResult1;
	TKey splitter01x;
	
	int max = elementCount - 2;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 2)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter01x)
			: "0"(splitter01x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters5OversamplingFactor2BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc, depthLimit - 1);
	}
}
template <typename ValueType, typename TKey>
void SampleSort3Splitters5OversamplingFactor2BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&))
{
	SampleSortInternal3Splitters5OversamplingFactor2BlockSize(A, elementCount, baseCaseLimit, sortFunc, predicateLess, getKeyFunc, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename ValueType, typename TKey>
inline
void SampleSortInternal3Splitters5OversamplingFactor3BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	TKey splitters[3];
	Find3Splitters5OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	TKey splitter0 = splitters[0];
	TKey splitter1 = splitters[1];
	TKey splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	TKey splitter00x;
	int state1;
	int predicateResult1;
	TKey splitter01x;
	int state2;
	int predicateResult2;
	TKey splitter02x;
	
	int max = elementCount - 3;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 3)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		state2 = predicateResult2;
		splitter02x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter01x)
			: "0"(splitter01x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter02x)
			: "0"(splitter02x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult2), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		state2 = (state2 << 1) + predicateResult2;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters5OversamplingFactor3BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc, depthLimit - 1);
	}
}
template <typename ValueType, typename TKey>
void SampleSort3Splitters5OversamplingFactor3BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&))
{
	SampleSortInternal3Splitters5OversamplingFactor3BlockSize(A, elementCount, baseCaseLimit, sortFunc, predicateLess, getKeyFunc, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename ValueType, typename TKey>
inline
void SampleSortInternal3Splitters5OversamplingFactor4BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	TKey splitters[3];
	Find3Splitters5OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	TKey splitter0 = splitters[0];
	TKey splitter1 = splitters[1];
	TKey splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	TKey splitter00x;
	int state1;
	int predicateResult1;
	TKey splitter01x;
	int state2;
	int predicateResult2;
	TKey splitter02x;
	int state3;
	int predicateResult3;
	TKey splitter03x;
	
	int max = elementCount - 4;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 4)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		state2 = predicateResult2;
		splitter02x = splitter0;
		predicateResult3 = (int) predicateLess(splitter1, A[current + 3]);
		state3 = predicateResult3;
		splitter03x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter01x)
			: "0"(splitter01x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter02x)
			: "0"(splitter02x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult2), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter03x)
			: "0"(splitter03x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult3), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		predicateResult3 = (int) predicateLess(splitter03x, A[current + 3]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		state2 = (state2 << 1) + predicateResult2;
		state3 = (state3 << 1) + predicateResult3;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
		*buckets[state3] = A[current + 3];
		buckets[state3]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters5OversamplingFactor4BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc, depthLimit - 1);
	}
}
template <typename ValueType, typename TKey>
void SampleSort3Splitters5OversamplingFactor4BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&))
{
	SampleSortInternal3Splitters5OversamplingFactor4BlockSize(A, elementCount, baseCaseLimit, sortFunc, predicateLess, getKeyFunc, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
template <typename ValueType, typename TKey>
inline
void SampleSortInternal3Splitters5OversamplingFactor5BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&),
	int depthLimit)
{
	if (elementCount <= baseCaseLimit)
	{
		sortFunc(A, elementCount);
		return;
	}
	
	if (depthLimit == 0)
	{
		insertionsort::InsertionSort<insertionsort::InsertionSort_Default>(A, elementCount);
		return;
	}
	TKey splitters[3];
	Find3Splitters5OversamplingFactor(A, elementCount, splitters, sortFunc, getKeyFunc);
	TKey splitter0 = splitters[0];
	TKey splitter1 = splitters[1];
	TKey splitter2 = splitters[2];
	
	ValueType *rawbuckets = (ValueType*) malloc(sizeof(ValueType) * 4 * elementCount);
	ValueType* buckets[4];
	for (int i = 0; i < 4; i += 1)
	{
		buckets[i] = &rawbuckets[i * elementCount];
	}
	int state0;
	int predicateResult0;
	TKey splitter00x;
	int state1;
	int predicateResult1;
	TKey splitter01x;
	int state2;
	int predicateResult2;
	TKey splitter02x;
	int state3;
	int predicateResult3;
	TKey splitter03x;
	int state4;
	int predicateResult4;
	TKey splitter04x;
	
	int max = elementCount - 5;
	int current = 0;
	//Sort 'blockSize' elements simultaneously into the buckets
	for ( ; current <= max; current += 5)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		predicateResult1 = (int) predicateLess(splitter1, A[current + 1]);
		state1 = predicateResult1;
		splitter01x = splitter0;
		predicateResult2 = (int) predicateLess(splitter1, A[current + 2]);
		state2 = predicateResult2;
		splitter02x = splitter0;
		predicateResult3 = (int) predicateLess(splitter1, A[current + 3]);
		state3 = predicateResult3;
		splitter03x = splitter0;
		predicateResult4 = (int) predicateLess(splitter1, A[current + 4]);
		state4 = predicateResult4;
		splitter04x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter01x)
			: "0"(splitter01x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult1), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter02x)
			: "0"(splitter02x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult2), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter03x)
			: "0"(splitter03x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult3), [zero] "r"(0)
			: "cc"
		);
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter04x)
			: "0"(splitter04x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult4), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		predicateResult1 = (int) predicateLess(splitter01x, A[current + 1]);
		predicateResult2 = (int) predicateLess(splitter02x, A[current + 2]);
		predicateResult3 = (int) predicateLess(splitter03x, A[current + 3]);
		predicateResult4 = (int) predicateLess(splitter04x, A[current + 4]);
		state0 = (state0 << 1) + predicateResult0;
		state1 = (state1 << 1) + predicateResult1;
		state2 = (state2 << 1) + predicateResult2;
		state3 = (state3 << 1) + predicateResult3;
		state4 = (state4 << 1) + predicateResult4;
		*buckets[state0] = A[current];
		buckets[state0]++;
		*buckets[state1] = A[current + 1];
		buckets[state1]++;
		*buckets[state2] = A[current + 2];
		buckets[state2]++;
		*buckets[state3] = A[current + 3];
		buckets[state3]++;
		*buckets[state4] = A[current + 4];
		buckets[state4]++;
	}
	
	//Sort the remaining k < 'blockSize' elements into the buckets
	for ( ; current < elementCount; current += 1)
	{
		predicateResult0 = (int) predicateLess(splitter1, A[current]);
		state0 = predicateResult0;
		splitter00x = splitter0;
		__asm__(
			"cmp %[predResult],%[zero]\n\t"
			"cmovcq %[splitter2],%[splitterx]\n\t"
			: [splitterx] "=&r"(splitter00x)
			: "0"(splitter00x), [splitter2] "r"(splitter2), [predResult] "r"(predicateResult0), [zero] "r"(0)
			: "cc"
		);
		predicateResult0 = (int) predicateLess(splitter00x, A[current]);
		state0 = (state0 << 1) + predicateResult0;
		*buckets[state0] = A[current];
		buckets[state0]++;
	}
	
	ValueType* currentPos = A;
	int bucketSize[4];
	int exclusiveBucketSizePrefixSum[4];
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);
		std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(ValueType));
		currentPos += bucketSize[currentBucket];
	}
	free(rawbuckets);
	
	exclusiveBucketSizePrefixSum[0] = 0;
	exclusiveBucketSizePrefixSum[1] = bucketSize[0];
	exclusiveBucketSizePrefixSum[2] = exclusiveBucketSizePrefixSum[1] + bucketSize[1];
	exclusiveBucketSizePrefixSum[3] = exclusiveBucketSizePrefixSum[2] + bucketSize[2];
	
	for (int currentBucket = 0; currentBucket < 4; currentBucket += 1)
	{
		SampleSortInternal3Splitters5OversamplingFactor5BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc, predicateLess, getKeyFunc, depthLimit - 1);
	}
}
template <typename ValueType, typename TKey>
void SampleSort3Splitters5OversamplingFactor5BlockSize(
	ValueType* A,
	size_t elementCount,
	size_t baseCaseLimit,
	void(*sortFunc)(ValueType*,size_t),
	bool(*predicateLess)(TKey&,ValueType&),
	TKey(*getKeyFunc)(ValueType&))
{
	SampleSortInternal3Splitters5OversamplingFactor5BlockSize(A, elementCount, baseCaseLimit, sortFunc, predicateLess, getKeyFunc, custommath::intlog2(elementCount) * 1.000000); //log to base {(numberOfSplitters + 1) / 2}
}
} // namespace samplesort

#endif // SAMPLESORT_GENERATED_H
