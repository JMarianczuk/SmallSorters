<#@ template language="C#" hostspecific="True" compilerOptions="/langversion:7"#>
<#@ output extension=".generated.h"#>

<#@ include file="Base.tt"#>

<#@ assembly name="System.Core"#>

<#@ import namespace="System"#>
<#@ import namespace="System.Collections.Generic"#>

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was auto-generated from a T4 template
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#ifndef SAMPLESORT_GENERATED_H
#define SAMPLESORT_GENERATED_H

#include <cstring>

namespace samplesort {

<#
    //currently asm blocks only do with 3 splitters
    for (int splits = 3; splits <= 3; splits = splits * 2 + 1)
    {
        for (int oversample = 1; oversample * splits <= 16; oversample += 1)
        {
            WriteFindSplitters(splits, oversample);
            for (int blockSize = 1; blockSize <= 5; blockSize += 1)
            {
                WriteRegisterSampleSort(splits, oversample, blockSize);
            }
        }
    }
    //WriteFindSplitters(3, 4);
    //WriteRegisterSampleSort(3, 4, 2);

    string GetName(int numberOfSplitters, int oversamplingFactor) => $"{numberOfSplitters}Splitters{oversamplingFactor}OversamplingFactor";
    void WriteFindSplitters(int numberOfSplitters, int oversamplingFactor)
    {
        int sampleSize = numberOfSplitters * oversamplingFactor;
        WriteLine("template <typename TValueType>");
        WriteLine("static inline");
        WriteLine($"void Find{GetName(numberOfSplitters, oversamplingFactor)}(");
        WriteIndented(() => {
            WriteLine("TValueType* items,");
            WriteLine("size_t elementCount,");
            WriteLine("TValueType* splitterDestination,");
            WriteLine("void(*sortFunc)(TValueType*,size_t))");
        });
        WriteBlock(() => {
            WriteLine($"TValueType sample[{sampleSize}];");
            WriteLine($"int blockSize = elementCount / {sampleSize};");
            WriteLine($"for (int i = 0; i < {sampleSize}; i += 1)");
            WriteBlock(() => {
                WriteLine($"sample[i] = items[i * blockSize];");
            });
            WriteLine($"sortFunc(sample, {sampleSize});");
            WriteLine("");

            WriteLine($"for (int i = 0; i < {numberOfSplitters}; i += 1)");
            WriteBlock(() => {
                WriteLine($"splitterDestination[i] = sample[i * {oversamplingFactor} + {oversamplingFactor / 2}];");
            });
        });
    }
    void WriteRegisterSampleSort(int numberOfSplitters, int oversamplingFactor, int blockSize)
    {
        var numberOfBuckets = numberOfSplitters + 1;
        WriteLine("template <typename TValueType>");
        WriteLine("static inline");
        WriteLine($"void SampleSort{GetName(numberOfSplitters, oversamplingFactor)}{blockSize}BlockSize(");
        WriteIndented(() => {
            WriteLine("TValueType* A,");
            WriteLine("size_t elementCount,");
            WriteLine("size_t baseCaseLimit,");
            WriteLine("void(*sortFunc)(TValueType*,size_t))");
        });
        WriteBlock(() => {
            WriteLine("if (elementCount <= baseCaseLimit)");
            WriteBlock(() => {
                WriteLine("sortFunc(A, elementCount);");
                WriteLine("return;");
            });
            WriteLine("");

            WriteLine($"TValueType splitters[{numberOfSplitters}];");
            WriteLine($"Find{GetName(numberOfSplitters, oversamplingFactor)}(A, elementCount, splitters, sortFunc);");
            for (int i = 0; i < numberOfSplitters; i += 1)
            {
                WriteLine($"register TValueType splitter{i} = splitters[{i}];");
            }
            WriteLine("");

            WriteLine($"TValueType rawbuckets[{numberOfBuckets} * elementCount];");
            WriteLine($"TValueType* buckets[{numberOfBuckets}];");
            WriteLine($"for (int i = 0; i < {numberOfBuckets}; i += 1)");
            WriteBlock(() => {
                WriteLine("buckets[i] = &rawbuckets[i * elementCount];");
            });

            for (int i = 0; i < blockSize; i += 1)
            {
                WriteLine($"register TValueType element{i};");
                WriteLine($"register int state{i};");
                WriteLine($"register TValueType splitter0{i}x;");
            }
            WriteLine("");

            WriteLine($"int max = elementCount - {blockSize};");
            WriteLine("int current = 0;");
            WriteLine($"//Sort {blockSize} elements simultaneously into the buckets");
            WriteLine($"for ( ; current <= max; current += {blockSize})");
            WriteBlock(() => WriteSortElementsIntoBuckets(numberOfSplitters, blockSize));
            WriteLine("");

            WriteLine($"//Sort the remaining k < {blockSize} elements into the buckets");
            WriteLine("for ( ; current < elementCount; current += 1)");
            WriteBlock(() => WriteSortElementsIntoBuckets(numberOfSplitters, 1));
            WriteLine("");

            WriteLine("TValueType* currentPos = A;");
            WriteLine($"int bucketSize[{numberOfBuckets}];");
            WriteLine($"int exclusiveBucketSizePrefixSum[{numberOfBuckets}];");
            WriteLine($"for (int currentBucket = 0; currentBucket < {numberOfBuckets}; currentBucket += 1)");
            WriteBlock(() => {
                WriteLine("bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);");
                WriteLine("std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(TValueType));");
                WriteLine("currentPos += bucketSize[currentBucket];");
            });
            WriteLine("");

            for (int i = 0; i < numberOfBuckets; i += 1)
            {
                if (i == 0) 
                {
                    WriteLine("exclusiveBucketSizePrefixSum[0] = 0;");
                }
                else if (i == 1)
                {
                    WriteLine("exclusiveBucketSizePrefixSum[1] = bucketSize[0];");
                }
                else
                {
                    WriteLine($"exclusiveBucketSizePrefixSum[{i}] = exclusiveBucketSizePrefixSum[{i-1}] + bucketSize[{i-1}];");
                }
            }
            WriteLine("");

            WriteLine($"for (int currentBucket = 0; currentBucket < {numberOfBuckets}; currentBucket += 1)");
            WriteBlock(() => {
                WriteLine($"SampleSort{GetName(numberOfSplitters, oversamplingFactor)}{blockSize}BlockSize(&A[exclusiveBucketSizePrefixSum[currentBucket]], bucketSize[currentBucket], baseCaseLimit, sortFunc);");
            });
        });
    }
    void WriteAsmBlock(Action writeContent, string indent = "\t")
    {
        WriteLine("__asm__(");
        PushIndent(indent);
        writeContent();
        PopIndent();
        WriteLine(");");
    }
    void WriteAsmLine(string content) => WriteLine($"\"{content}\\n\\t\"");
    void WriteSortElementsIntoBuckets(int numberOfSplitters, int blockSize)
    {
        Func<int, string> getPlusI = (i) => i > 0 ? $" + {i}" : "";
        for (int i = 0; i < blockSize; i += 1)
        {
            WriteLine($"element{i} = A[current{getPlusI(i)}];");
            WriteLine($"state{i} = 0;");
            WriteLine($"splitter0{i}x = splitter0;");
        }
        for (int i = 0; i < blockSize; i += 1)
        {
            WriteAsmBlock(() => {
                WriteAsmLine("cmp %[ele],%[splitter1]");
                WriteAsmLine("cmovc %[splitter2],%[splitterx]");
                WriteAsmLine("rcl $1,%[state]");
                WriteLine($": [splitterx] \"+r\"(splitter0{i}x), [state] \"=r\"(state{i})");
                WriteLine($": \"1\"(state{i}), [ele] \"r\"(element{i}), [splitter1] \"r\"(splitter1), [splitter2] \"r\"(splitter2)");
                WriteLine(": \"cc\"");
            });
            WriteAsmBlock(() => {
                WriteAsmLine("cmp %[ele],%[splitterx]");
                WriteAsmLine("rcl $1,%[state]");
                WriteLine($": [state] \"=r\"(state{i})");
                WriteLine($": \"0\"(state{i}), [ele] \"r\"(element{i}), [splitterx] \"r\"(splitter0{i}x)");
                WriteLine(": \"cc\"");
            });
        }
        for (int i = 0; i < blockSize; i += 1)
        {
            WriteLine($"*buckets[state{i}] = element{i};");
            WriteLine($"buckets[state{i}]++;");
        }
    }
#>

}

#endif
