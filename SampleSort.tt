<#@ template language="C#" hostspecific="True" compilerOptions="/langversion:7"#>
<#@ output extension=".generated.h"#>

<#@ include file="Base.tt"#>

<#@ assembly name="System.Core"#>

<#@ import namespace="System"#>
<#@ import namespace="System.Collections.Generic"#>

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was auto-generated from a T4 template
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#ifndef SAMPLESORT_GENERATED_H
#define SAMPLESORT_GENERATED_H

<#
    WriteRegisterSampleSort(3, 2);
    void WriteRegisterSampleSort(int numberOfSplitters, int blockSize)
    {
        var numberOfBuckets = numberOfSplitters + 1;
        WriteLine("template <typename TValueType>");
        WriteLine("static inline");
        WriteLine($"void SampleSort{numberOfSplitters}Splitters{blockSize}BlockSize(TValueType* A, int elementCount, TValueType* splitters)");
        WriteBlock(() => {
            for (int i = 0; i < numberOfSplitters; i += 1)
            {
                WriteLine($"register TValueType splitter{i} = splitters[{i}];");
            }
            WriteLine("");

            WriteLine($"TValueType rawbuckets[{numberOfBuckets} * elementCount];");
            WriteLine($"TValueType* buckets[{numberOfBuckets}];");
            WriteLine($"for (int i = 0; i < {numberOfBuckets}; i += 1)");
            WriteBlock(() => {
                WriteLine("buckets[i] = &rawbuckets[i * elementCount];");
            });

            for (int i = 0; i < blockSize; i += 1)
            {
                WriteLine($"register TValueType element{i};");
                WriteLine($"register uint8_t state{i};");
                WriteLine($"register TValueType splitter0{i}x;");
            }
            WriteLine("");

            WriteLine("int max = elementCount - blockSize;");
            WriteLine("int current = 0;");
            WriteLine("for ( ; current < max; current += blockSize)");
            WriteBlock(() => WriteSortElementsIntoBuckets(blockSize));
            WriteLine("");

            WriteLine("for ( ; current < elementCount; current += 1)");
            WriteBlock(() => WriteSortElementsIntoBuckets(1));
        });
    }
    void WriteSortElementsIntoBuckets(int blockSize)
    {
        Func<int, string> getPlusI = (i) => i > 0 ? $" + {i}" : "";
        for (int i = 0; i < blockSize; i += 1)
        {
            WriteLine($"element{i} = A[current{getPlusI(i)}];");
            WriteLine($"state{i} = 0;");
            WriteLine($"splitter0{i}x = splitter1;");
        }
        for (int i = 0; i < blockSize; i += 1)
        {
            WriteAsmBlock(() => {
                WriteAsmLine("cmp %[ele],%[splitter2]");
                WriteAsmLine("cmovc %[splitter3],%[splitterx]");
                WriteAsmLine("rcl $1,%[state]");
                WriteLine($": [splitterx] \"+r\"(splitter0{i}x), [state] \"=r\"(state{i})");
                WriteLine($": [ele] \"r\"(element{i}), [splitter2] \"r\"(splitter2), [splitter3] \"r\"(splitter3)");
                WriteLine("\"cc\"");
            });
            WriteAsmBlock(() => {
                WriteAsmLine("cmp %[ele],%[splitterx]");
                WriteAsmLine("rcl $1,%[state]");
                WriteLine($": [state] \"=r\"(state{i})");
                WriteLine($": [ele] \"r\"(element{i}), [splitterx] \"r\"(splitter0{i}x)");
                WriteLine("\"cc\"");
            });
        }
        for (int i = 0; i < blockSize; i += 1)
        {
            WriteLine($"*buckets[state{i}] = element{i};");
            WriteLine($"buckets[state{i}]++;");
        }
    }
    void WriteAsmBlock(Action writeContent, string indent = "\t")
    {
        WriteLine("__asm__(");
        PushIndent(indent);
        writeContent();
        PopIndent();
        WriteLine(");");
    }
    void WriteAsmLine(string content) => WriteLine($"\"{content}\\n\\t\"");
#>

#endif
