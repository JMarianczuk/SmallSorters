<#@ template language="C#" hostspecific="True" compilerOptions="/langversion:7"#>
<#@ output extension=".generated.h"#>

<#@ include file="Base.tt"#>

<#@ assembly name="System.Core"#>

<#@ import namespace="System"#>
<#@ import namespace="System.Collections.Generic"#>

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was auto-generated from a T4 template
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#ifndef SAMPLESORT_GENERATED_H
#define SAMPLESORT_GENERATED_H

#include <cstring>

<#
    WriteRegisterSampleSort(3, 2);
    void WriteRegisterSampleSort(int numberOfSplitters, int blockSize)
    {
        var numberOfBuckets = numberOfSplitters + 1;
        WriteLine("template <typename TValueType>");
        WriteLine("static inline");
        WriteLine($"void SampleSort{numberOfSplitters}Splitters{blockSize}BlockSize(TValueType* A, int elementCount, TValueType* splitters)");
        WriteBlock(() => {
            for (int i = 0; i < numberOfSplitters; i += 1)
            {
                WriteLine($"register TValueType splitter{i} = splitters[{i}];");
            }
            WriteLine("");

            WriteLine($"TValueType rawbuckets[{numberOfBuckets} * elementCount];");
            WriteLine($"TValueType* buckets[{numberOfBuckets}];");
            WriteLine($"for (int i = 0; i < {numberOfBuckets}; i += 1)");
            WriteBlock(() => {
                WriteLine("buckets[i] = &rawbuckets[i * elementCount];");
            });

            for (int i = 0; i < blockSize; i += 1)
            {
                WriteLine($"register TValueType element{i};");
                WriteLine($"register int state{i};");
                WriteLine($"register TValueType splitter0{i}x;");
            }
            WriteLine("");

            WriteLine($"int max = elementCount - {blockSize};");
            WriteLine("int current = 0;");
            WriteLine($"//Sort {blockSize} elements simultaneously into the buckets");
            WriteLine($"for ( ; current <= max; current += {blockSize})");
            WriteBlock(() => WriteSortElementsIntoBuckets(blockSize));
            WriteLine("");

            WriteLine($"//Sort the remaining k < {blockSize} elements into the buckets");
            WriteLine("for ( ; current < elementCount; current += 1)");
            WriteBlock(() => WriteSortElementsIntoBuckets(1));
            WriteLine("");

            WriteLine("TValueType* currentPos = A;");
            WriteLine($"int bucketSize[{numberOfBuckets}];");
            WriteLine($"for (int currentBucket = 0; currentBucket < {numberOfBuckets}; currentBucket += 1)");
            WriteBlock(() => {
                WriteLine("bucketSize[currentBucket] = (int) (buckets[currentBucket] - &rawbuckets[currentBucket * elementCount]);");
                WriteLine("std::memcpy((void*) currentPos, (void*) &rawbuckets[currentBucket * elementCount], bucketSize[currentBucket] * sizeof(TValueType));");
                WriteLine("currentPos += bucketSize[currentBucket];");
            });
        });
    }
    void WriteAsmBlock(Action writeContent, string indent = "\t")
    {
        WriteLine("__asm__(");
        PushIndent(indent);
        writeContent();
        PopIndent();
        WriteLine(");");
    }
    void WriteAsmLine(string content) => WriteLine($"\"{content}\\n\\t\"");
    void WriteSortElementsIntoBuckets(int blockSize)
    {
        Func<int, string> getPlusI = (i) => i > 0 ? $" + {i}" : "";
        for (int i = 0; i < blockSize; i += 1)
        {
            WriteLine($"element{i} = A[current{getPlusI(i)}];");
            WriteLine($"state{i} = 0;");
            WriteLine($"splitter0{i}x = splitter0;");
        }
        for (int i = 0; i < blockSize; i += 1)
        {
            WriteAsmBlock(() => {
                WriteAsmLine("cmp %[ele],%[splitter1]");
                WriteAsmLine("cmovc %[splitter2],%[splitterx]");
                WriteAsmLine("rcl $1,%[state]");
                WriteLine($": [splitterx] \"+r\"(splitter0{i}x), [state] \"=r\"(state{i})");
                WriteLine($": \"1\"(state{i}), [ele] \"r\"(element{i}), [splitter1] \"r\"(splitter1), [splitter2] \"r\"(splitter2)");
                WriteLine(": \"cc\"");
            });
            WriteAsmBlock(() => {
                WriteAsmLine("cmp %[ele],%[splitterx]");
                WriteAsmLine("rcl $1,%[state]");
                WriteLine($": [state] \"=r\"(state{i})");
                WriteLine($": \"0\"(state{i}), [ele] \"r\"(element{i}), [splitterx] \"r\"(splitter0{i}x)");
                WriteLine(": \"cc\"");
            });
        }
        for (int i = 0; i < blockSize; i += 1)
        {
            WriteLine($"*buckets[state{i}] = element{i};");
            WriteLine($"buckets[state{i}]++;");
        }
    }
#>

#endif
