
#include "WriteNetwork.hpp"

namespace codegeneration
{

void WriteNetwork(CPlusPlusCodeGenerator *gen, std::string headerDefine, std::string nested_namespace_name, std::string networksJsonFilePath)
{
    std::ifstream input(networksJsonFilePath);
    nlohmann::json networksJson;
    input >> networksJson;

    gen->WriteLine(GetAutogeneratedPreamble());
    gen->WriteLine("");

    gen->WriteHeaderPragma(headerDefine, [=]{
        gen->WriteIncludeQuotes(
            "../conditional_swap/ConditionalSwapGeneric.h",
            "../conditional_swap/ConditionalSwapX86.h");
        gen->WriteNamespace("networks", [=]{
            gen->WriteNamespace(nested_namespace_name, [=]{
                for (auto network : networksJson)
                {
                    std::string sizeStr = std::to_string(network["NetworkSize"].get<int>());
                    gen->WriteLine("template <typename CSwap, typename ValueType> static");
                    gen->WriteLine("void sort", sizeStr, "(ValueType* A)");
                    gen->WriteBlock([=]{
                        for (auto swap : network["Swaps"])
                        {
                            std::string leftStr = std::to_string(swap["LeftIndex"].get<int>());
                            std::string rightStr = std::to_string(swap["RightIndex"].get<int>());
                            gen->WriteLine("CSwap::swap(A[", leftStr, "], A[", rightStr, "]);");
                        }
                    });
                }
                gen->WriteLine("");
                gen->WriteLine("template <typename CSwap, typename ValueType> static");
                gen->WriteLine("void sortN(ValueType* A, size_t n)");
                gen->WriteBlock([=]{
                    gen->WriteLine("switch(n)");
                    gen->WriteBlock([=]{
                        gen->WriteLine("case 0: break;");
                        gen->WriteLine("case 1: break;");
                        for (auto network : networksJson)
                        {
                            std::string sizeStr = std::to_string(network["NetworkSize"].get<int>());
                            gen->WriteLine("case ", sizeStr, ":");
                            gen->WriteIndented([=]{
                                gen->WriteLine("sort", sizeStr, "<CSwap>(A);");
                                gen->WriteLine("break;");
                            });
                        }
                        gen->WriteLine("default:");
                        gen->WriteIndented([=]{
                            gen->WriteLine("abort();");
                            gen->WriteLine("break;");
                        });
                    });
                });
            }, "");
        }, "");
    });
}

void WriteSortMethodName_ParameterStyle(CodeGenerator *gen, int networkSize)
{
    gen->Write("void sort");
    gen->Write(networkSize);
    gen->Write("(");
    for (int i = 0; i < networkSize - 1; i += 1)
    {
        gen->Write("ValueType& element");
        gen->Write(i);
        gen->Write(", ");
    }
    gen->Write("ValueType& element");
    gen->Write(networkSize - 1);
    gen->WriteLine(")");
}

void WriteMergeMethodName_ParameterStyle(CodeGenerator *gen, int leftMergeSize, int rightMergeSize)
{
    gen->Write("void merge_");
    gen->Write(leftMergeSize);
    gen->Write("_");
    gen->Write(rightMergeSize);
    gen->Write("(");
    for (int i = 0; i < leftMergeSize; i += 1)
    {
        gen->Write("ValueType& left");
        gen->Write(i);
        gen->Write(", ");
    }
    for (int i = 0; i < rightMergeSize - 1; i += 1)
    {
        gen->Write("ValueType& right");
        gen->Write(i);
        gen->Write(", ");
    }
    gen->Write("ValueType& right");
    gen->Write(rightMergeSize - 1);
    gen->WriteLine(")");
}

void WriteParameters(CodeGenerator *gen, nlohmann::json leftIndices, nlohmann::json rightIndices, std::string leftElementsName, std::string rightElementsName)
{
    for (auto leftIndex : leftIndices)
    {
        gen->Write(leftElementsName);
        gen->Write(leftIndex.get<int>());
        gen->Write(", ");
    }
    for (auto it = rightIndices.begin(); it < rightIndices.end() - 1; it++)
    {
        gen->Write(rightElementsName);
        gen->Write((*it).get<int>());
        gen->Write(", ");
    }
    gen->Write(rightElementsName);
    gen->Write(rightIndices.back().get<int>());
}

bool IsInline(nlohmann::json network, RecursiveParameterNetworkType networkType)
{
    //return true; //Worse performance for only inlining the small networks -> probably due to the fact that too many parameters have to be pushed on the stack
    switch (networkType)
    {
        case RecursiveParameterNetworkType::Split:
            return network["NetworkSize"].get<int>() == 2;
        case RecursiveParameterNetworkType::Merge:
            return (network["LeftMergeSize"].get<int>() + network["RightMergeSize"].get<int>()) <= 3;
    }
    
}

void WriteSorter_ParameterStyle(
    CodeGenerator *gen, 
    nlohmann::json network,
    std::string nested_namespace_name,
    bool* splitIndices, 
    bool* mergeIndices, 
    int indexArrayLength)
{
    for (auto step : network["RecursiveSteps"])
    {
        auto stepNetwork = step["Network"];
        auto stepType = stepNetwork["Type"].get<std::string>();
        if (stepType.compare("Split") == 0)
        {
            int length = stepNetwork["NetworkSize"].get<int>();
            if (!splitIndices[length])
            {
                WriteSorter_ParameterStyle(
                    gen, 
                    stepNetwork,
                    nested_namespace_name,
                    splitIndices, 
                    mergeIndices, 
                    indexArrayLength);
            }
        }
        if (stepType.compare("Merge") == 0)
        {
            int leftSize = stepNetwork["LeftMergeSize"].get<int>();
            int rightSize = stepNetwork["RightMergeSize"].get<int>();
            if (!mergeIndices[leftSize * indexArrayLength + rightSize])
            {
                WriteSorter_ParameterStyle(
                    gen, 
                    stepNetwork,
                    nested_namespace_name,
                    splitIndices, 
                    mergeIndices, 
                    indexArrayLength);
            }
        }
    }

    RecursiveParameterNetworkType networkType;
    auto type = network["Type"].get<std::string>();
    if (type.compare("Split") == 0)
    {
        networkType = RecursiveParameterNetworkType::Split;
    }
    else if (type.compare("Merge") == 0)
    {
        networkType = RecursiveParameterNetworkType::Merge;
    }

    gen->WriteLine("template <typename CSwap, typename ValueType> static");
    gen->WriteLine("inline");

    int networkSize;
    int leftMergeSize;
    int rightMergeSize;
    switch (networkType)
    {
        case RecursiveParameterNetworkType::Split:
            networkSize = network["NetworkSize"].get<int>();
            WriteSortMethodName_ParameterStyle(gen, networkSize);
            splitIndices[networkSize] = true;
            break;
        case RecursiveParameterNetworkType::Merge:
            leftMergeSize = network["LeftMergeSize"].get<int>();
            rightMergeSize = network["RightMergeSize"].get<int>();
            WriteMergeMethodName_ParameterStyle(gen, leftMergeSize, rightMergeSize);
            mergeIndices[leftMergeSize * indexArrayLength + rightMergeSize] = true;
            if (leftMergeSize == 1 && rightMergeSize == 1)
            {
                gen->WriteBlock([=]{
                    gen->WriteLine("CSwap::swap(left0, right0);");
                });
                return;
            }
            else if (leftMergeSize == 1 && rightMergeSize == 2)
            {
                gen->WriteBlock([=]{
                    gen->WriteLine("CSwap::swap(left0, right1);");
                    gen->WriteLine("CSwap::swap(left0, right0);");
                });
                return;
            }
            else if (leftMergeSize == 2 && rightMergeSize == 1)
            {
                gen->WriteBlock([=]{
                    gen->WriteLine("CSwap::swap(left0, right0);");
                    gen->WriteLine("CSwap::swap(left1, right0);");
                });
                return;
            }
            break;
    }
    gen->WriteBlock([=]{
        for (auto step : network["RecursiveSteps"])
        {
            auto stepNetwork = step["Network"];
            auto stepType = stepNetwork["Type"].get<std::string>();
            if (stepType.compare("Split") == 0)
            {
                int stepSize = stepNetwork["NetworkSize"].get<int>();
                auto indicesToUse = step["FirstContextParameterIdsToUse"];
                gen->Write("networks::");
                gen->Write(nested_namespace_name);
                gen->Write("::sort");
                gen->Write(stepSize);
                gen->Write("<CSwap>(");
                for (auto it = indicesToUse.begin(); it < indicesToUse.end() - 1; it++)
                {
                    gen->Write("element");
                    gen->Write((*it).get<int>());
                    gen->Write(", ");
                }
                gen->Write("element");
                gen->Write(indicesToUse.back().get<int>());
                gen->WriteLine(");");
            }
            else 
            {
                int leftMergeSize = stepNetwork["LeftMergeSize"].get<int>();
                int rightMergeSize = stepNetwork["RightMergeSize"].get<int>();
                auto leftIndices = step["FirstContextParameterIdsToUse"];
                auto rightIndices = step["SecondContextParameterIdsToUse"];
                gen->Write("networks::");
                gen->Write(nested_namespace_name);
                gen->Write("::merge_");
                gen->Write(leftMergeSize);
                gen->Write("_");
                gen->Write(rightMergeSize);
                gen->Write("<CSwap>(");
                //Step is merge step
                switch (networkType)
                {
                    case RecursiveParameterNetworkType::Split:
                        WriteParameters(gen, leftIndices, rightIndices, "element", "element");
                        gen->WriteLine(");");
                        break;
                    case RecursiveParameterNetworkType::Merge:
                        WriteParameters(gen, leftIndices, rightIndices, "left", "right");
                        gen->WriteLine(");");
                        break;
                }
            }
        }  
    });
    gen->WriteLine("");
}

void WriteNetwork_ParameterStyle(CPlusPlusCodeGenerator *gen, std::string headerDefine, std::string nested_namespace_name, std::string networksJsonFilePath)
{
    std::ifstream input(networksJsonFilePath);
    nlohmann::json networksJson;
    input >> networksJson;

    int maxLength = networksJson.back()["NetworkSize"].get<int>();
    int indexLength = maxLength + 1;
    bool *splitIndices = (bool*) malloc(indexLength * sizeof(bool));
    bool *mergeIndices = (bool*) malloc(indexLength * indexLength * sizeof(bool));

    for (int outer = 0; outer < indexLength; outer += 1)
    {
        splitIndices[outer] = false;
        for (int inner = 0; inner < indexLength; inner += 1)
        {
            mergeIndices[outer * indexLength + inner] = false;
        }
    }

    gen->WriteLine(GetAutogeneratedPreamble());
    gen->WriteLine("");

    gen->WriteHeaderPragma(headerDefine, [=]{
        gen->WriteIncludeQuotes(
            "../conditional_swap/ConditionalSwapGeneric.h",
            "../conditional_swap/ConditionalSwapX86.h");
        gen->WriteNamespace("networks", [=]{
            gen->WriteNamespace(nested_namespace_name, [=]{
                for (auto network : networksJson)
                {
                    WriteSorter_ParameterStyle(
                        gen, 
                        network,
                        nested_namespace_name,
                        splitIndices, 
                        mergeIndices, 
                        maxLength + 1);
                }
                gen->WriteLine("");

                gen->WriteLine("template <typename CSwap, typename ValueType> static");
                gen->WriteLine("void sortN(ValueType* A, size_t n)");
                gen->WriteBlock([=]{
                    gen->WriteLine("switch(n)");
                    gen->WriteBlock([=]{
                        gen->WriteLine("case 0: break;");
                        gen->WriteLine("case 1: break;");
                        for (int arraySize = 2; arraySize <= maxLength; arraySize += 1)
                        {
                            auto sizeStr = std::to_string(arraySize);
                            gen->WriteLine("case ", sizeStr, ":");
                            gen->WriteIndented([=]{
                                gen->Write("networks::");
                                gen->Write(nested_namespace_name);
                                gen->Write("::sort");
                                gen->Write(sizeStr);
                                gen->Write("<CSwap>(");
                                for (int i = 0; i < arraySize - 1; i += 1)
                                {
                                    gen->Write("A[");
                                    gen->Write(i);
                                    gen->Write("], ");
                                }
                                gen->Write("A[");
                                gen->Write(arraySize - 1);
                                gen->WriteLine("]);");
                                gen->WriteLine("break;");
                            });
                        }
                    });
                });
            }, "");
        }, "");
    });
    free(splitIndices);
    free(mergeIndices);
}

void WriteSorter_RecursiveStyle(
    CodeGenerator *gen, 
    nlohmann::json network,
    std::string nested_namespace_name,
    bool* splitIndices, 
    bool* mergeIndices, 
    int indexArrayLength)
{
    for (auto step : network["RecursiveSteps"])
    {
        auto stepNetwork = step["Network"];
        auto stepType = stepNetwork["Type"].get<std::string>();
        if (stepType.compare("Split") == 0)
        {
            int length = stepNetwork["NetworkSize"].get<int>();
            if (!splitIndices[length])
            {
                WriteSorter_RecursiveStyle(
                    gen,
                    stepNetwork,
                    nested_namespace_name,
                    splitIndices,
                    mergeIndices,
                    indexArrayLength);
            }
        }
        if (stepType.compare("Merge") == 0)
        {
            int leftSize = stepNetwork["LeftMergeSize"].get<int>();
            int rightSize = stepNetwork["RightMergeSize"].get<int>();
            if (!mergeIndices[leftSize * indexArrayLength + rightSize])
            {
                WriteSorter_RecursiveStyle(
                    gen,
                    stepNetwork,
                    nested_namespace_name,
                    splitIndices,
                    mergeIndices,
                    indexArrayLength);
            }
        }
    }

    RecursiveParameterNetworkType networkType;
    auto type = network["Type"].get<std::string>();
    if (type.compare("Split") == 0)
    {
        networkType = RecursiveParameterNetworkType::Split;
    }
    else if (type.compare("Merge") == 0)
    {
        networkType = RecursiveParameterNetworkType::Merge;
    }

    gen->WriteLine("template <typename CSwap, typename ValueType> static");
    if (IsInline(network, networkType))
    {
        gen->WriteLine("inline");
    }

    int networkSize;
    int leftMergeSize;
    int rightMergeSize;
    switch (networkType)
    {
        case RecursiveParameterNetworkType::Split:
            networkSize = network["NetworkSize"].get<int>();
            gen->WriteLine("void sort", std::to_string(networkSize), "(ValueType* A)");
            splitIndices[networkSize] = true;
            break;
        case RecursiveParameterNetworkType::Merge:
            leftMergeSize = network["LeftMergeSize"].get<int>();
            rightMergeSize = network["RightMergeSize"].get<int>();
            gen->WriteLine("void merge", std::to_string(leftMergeSize), "_", std::to_string(rightMergeSize), "(ValueType* left, ValueType* right)");
            mergeIndices[leftMergeSize * indexArrayLength + rightMergeSize] = true;
            if (leftMergeSize == 1 && rightMergeSize == 1)
            {
                gen->WriteBlock([=]{
                    gen->WriteLine("CSwap::swap(left[0], right[0]);");
                });
                return;
            }
            else if (leftMergeSize == 1 && rightMergeSize == 2)
            {
                gen->WriteBlock([=]{
                    gen->WriteLine("CSwap::swap(left[0], right[1]);");
                    gen->WriteLine("CSwap::swap(left[0], right[0]);");
                });
                return;
            }
            else if (leftMergeSize == 2 && rightMergeSize == 1)
            {
                gen->WriteBlock([=]{
                    gen->WriteLine("CSwap::swap(left[0], right[0]);");
                    gen->WriteLine("CSwap::swap(left[1], right[0]);");
                });
                return;
            }
            break;
    }
    gen->WriteBlock([=]{
        for (auto step : network["RecursiveSteps"])
        {
            auto stepNetwork = step["Network"];
            auto stepType = stepNetwork["Type"].get<std::string>();
            if (stepType.compare("Split") == 0)
            {
                int stepSize = stepNetwork["NetworkSize"].get<int>();
                int indexToUse = (*step["FirstContextParameterIdsToUse"].begin()).get<int>();
                std::string addStr = "";
                if (indexToUse > 0)
                {
                    addStr = " + " + std::to_string(indexToUse);
                }
                gen->WriteLine("networks::", nested_namespace_name, "::sort", std::to_string(stepSize), "<CSwap>(A", addStr, ");");
            }
            else if (stepType.compare("Merge") == 0)
            {
                int leftMergeSize = stepNetwork["LeftMergeSize"].get<int>();
                int rightMergeSize = stepNetwork["RightMergeSize"].get<int>();
                int leftIndex = (*step["FirstContextParameterIdsToUse"].begin()).get<int>();
                int rightIndex = (*step["SecondContextParameterIdsToUse"].begin()).get<int>();
                std::string leftAddStr = "";
                std::string rightAddStr = "";
                if (leftIndex > 0)
                {
                    leftAddStr = " + " + std::to_string(leftIndex);
                }
                if (rightIndex > 0)
                {
                    rightAddStr = " + " + std::to_string(rightIndex);
                }
                std::string callStr;
                switch (networkType)
                {
                    case RecursiveParameterNetworkType::Split:
                        callStr = "A" + leftAddStr + ", A" + rightAddStr;
                        break;
                    case RecursiveParameterNetworkType::Merge:
                        callStr = "left" + leftAddStr + ", right" + rightAddStr;
                        break;
                }
                gen->WriteLine("networks::", nested_namespace_name, "::merge", std::to_string(leftMergeSize), "_", std::to_string(rightMergeSize), "<CSwap>(", callStr, ");");
            }
        }
    });
    gen->WriteLine("");
}

void WriteNetwork_RecursiveStyle(CPlusPlusCodeGenerator *gen, std::string headerDefine, std::string nested_namespace_name, std::string networksJsonFilePath)
{
    std::ifstream input(networksJsonFilePath);
    nlohmann::json networksJson;
    input >> networksJson;

    int maxLength = networksJson.back()["NetworkSize"].get<int>();
    int indexLength = maxLength + 1;
    bool* splitIndices = (bool*) malloc(indexLength * sizeof(bool));
    bool* mergeIndices = (bool*) malloc(indexLength * indexLength * sizeof(bool));

    for (int outer = 0; outer < indexLength; outer += 1)
    {
        splitIndices[outer] = false;
        for (int inner = 0; inner < indexLength; inner += 1)
        {
            mergeIndices[outer * indexLength + inner] = false;
        }
    }

    gen->WriteLine(GetAutogeneratedPreamble());
    gen->WriteLine("");

    gen->WriteHeaderPragma(headerDefine, [=]{
        gen->WriteIncludeQuotes(
            "../conditional_swap/ConditionalSwapGeneric.h",
            "../conditional_swap/ConditionalSwapX86.h");
        gen->WriteNamespace("networks", [=]{
            gen->WriteNamespace(nested_namespace_name, [=]{
                for (auto network : networksJson)
                {
                    WriteSorter_RecursiveStyle(
                        gen,
                        network,
                        nested_namespace_name,
                        splitIndices,
                        mergeIndices,
                        maxLength + 1);
                }
                gen->WriteLine("");

                gen->WriteLine("template <typename CSwap, typename ValueType> static");
                gen->WriteLine("void sortN(ValueType* A, size_t n)");
                gen->WriteBlock([=]{
                    gen->WriteLine("switch(n)");
                    gen->WriteBlock([=]{
                        gen->WriteLine("case 0: break;");
                        gen->WriteLine("case 1: break;");
                        for (int arraySize = 2; arraySize <= maxLength; arraySize += 1)
                        {
                            auto sizeStr = std::to_string(arraySize);
                            gen->WriteLine("case ", sizeStr, ":");
                            gen->WriteIndented([=]{
                                gen->WriteLine("networks::", nested_namespace_name, "::sort", sizeStr, "<CSwap>(A);");
                                gen->WriteLine("break;");
                            });
                        }
                    });
                });
            }, "");
        }, "");
    });
    
    free(splitIndices);
    free(mergeIndices);
}

}