
#ifndef GENERATE_SORTABLE_STRUCTS_H
#define GENERATE_SORTABLE_STRUCTS_H

#include "CodeGeneration.h"
#include "SortableDefinitions.h"
#include "FunctionalHelpers.h"

namespace codegeneration
{

void WriteVariables(CodeGenerator* gen, SortableStruct* sortableStruct)
{
    gen->WriteLine("uint64_t key;");
    if (sortableStruct->HasReference)
    {
        gen->WriteLine("uint64_t reference;");
    }
}

void WriteOperator(CodeGenerator* gen, SortableStruct* sortableStruct, std::string op)
{
    gen->Write("friend bool operator");
    gen->Write(op);
    gen->Write("(const ");
    gen->Write(sortableStruct->FullName());
    gen->Write("& left, const ");
    gen->Write(sortableStruct->FullName());
    gen->WriteLine("& right)");

    gen->WriteBlock([=]{
        gen->Write("return left.key ");
        gen->Write(op);
        gen->WriteLine(" right.key;");
    });
}

void WriteOperators(CodeGenerator* gen, SortableStruct* sortableStruct)
{
    Multicall<std::string>(
        [=](std::string op){
            WriteOperator(gen, sortableStruct, op);
        },
        {">", "==", "<", "!="});
}

void WriteSortableStructs(CodeGenerator* gen)
{
    gen->WriteLine(AutogeneratedPreamble);
    gen->WriteLine("");
    gen->WriteHeaderPragma("SORTABLE_GENERATED_H", [=]{
        gen->WriteLine("#define ArraySize 16");
        gen->WriteIncludeBrackets("inttypes.h");
        for (SortableStruct* sortableStruct : sortableStructs)
        {
            gen->Write("struct ");
            gen->WriteLine(sortableStruct->FullName());
            gen->WriteLine("{");
            gen->WriteIndented([=]{
                WriteVariables(gen, sortableStruct);
                WriteOperators(gen, sortableStruct);
            });
            gen->WriteLine("};");
        }
    });
}

}

#endif